---
title: 计算机组成原理
date: 2020-06-10 12:35:51
tags: 硬件
categories: 硬件
---
计算机组成原理，好难啊啊啊啊啊
<!-- more -->

# 计算机系统概论



## 计算机性能指标
**吞吐量**：表征一台计算机在某一时间间隔内能够处理的信息量，单位是字节/秒（B/s）。

**响应时间**：表征从输入有效到系统产生响应之间的时间度量，用时间单位来度量，例如微秒us（10^(-6)s）、纳秒ns（10^(-9)s）。

**利用率**：在给定的时间间隔内，系统被实际使用的时间所占的比率，一般用百分比表示。

**处理机字长**：指处理机运算器中一次能够完成二进制数运算的位数，决定了寄存器和数据总线的位数。当前处理机的字长有8位、16位、32位、64位。

字长越长，包含的信息量越多，精度越高，硬件成本也越高

**总线宽度**：一般指CPU中运算器与存储器之间进行互连的内部总线二进制位数。

**存储容量**：存储器中所有存储单元的总数目，通常用KB、MB、GB、TB来表示。其中K=2^10，M=2^20，G=2^30，T=2^40，B=8位（1个字节）。

存储器容量越大，记忆的二进制数越多。有内存容量和辅存容量两种指标。存储容量越大，能存储的信息就越多。
                    1KB=1024B，1MB=1024KB，
                    1GB=1024MB，1TB=1024GB

**存储器带宽**：存储器的速度指标，单位时间内从存储器读出的二进制数信息量，一般用`字节数/秒`表示。
带宽的计算：`存储带宽`、`总线带宽`、`显示带宽`等
通信中的带宽使用的单位有：
```
  “千比特/秒”(kb/s)，     1kbps = 103 b/s =1000 bps
  “兆比特/秒”(Mb/s)，   1Mbps = 106 b/s =1000 kbps
  “千兆比特/秒”(Gb/s)，1Gbps = 109 b/s =1000 Mbps
  “兆兆比特/秒”(Tb/s)， 1Tbps = 1012b/s =1000 Gbps
```

如果把b换成B，则表示字节而不是比特（位），例如，10MBps表示 10兆字节/秒。

**主频/时钟周期**：CPU的工作节拍受主时钟控制，主时钟不断产生固定频率的时钟，`主时钟的频率（f）`叫CPU的`主频`。度量单位是MHz、GHz。
    例如Pentium系列机为60MHz～266MHz，而Pentium 4升至3.6GHz。
`主频的倒数`称为`CPU时钟周期`（T），即`T=1/f`，度量单位是`微秒us` 、`纳秒ns`。

**CPU执行时间**：表示CPU执行一段程序所占用的CPU时间，可用下式计算：
    `CPU执行时间 ＝ CPU时钟周期数 × CPU时钟周期长（T）`

**CPI**：每条指令周期数，即执行一条指令所需的平均时钟周期数。
           `CPI = "执行某段程序所需的CPU时钟周期数" /"程序包含的指令条数" `

**MIPS**：每秒百万条指令数，表示单位时间内执行的指令数目。
           `MIPS = "指令条数" /"程序执行时间×10^6"  = "时钟频率" /"CPI×10^6"  = "f" /"CPI×10^6" `

**MFLOPS**：每秒百万次浮点操作次数，用来衡量机器浮点操作的性能。
`MIPS`是单位时间内的执行指令数，所以MIPS值越高说明机器速度越快。  
`MFLOPS`是基于操作而非指令的，只能用来衡量机器浮点操作的性能，而不能体现机器的整体性能。
`TFLOPS`表示每秒万亿次浮点操作次数，该技术指标一般在超级计算机中使用。


## 计算机的硬件
### 硬件组成要素
存储器、运算器、控制器、输入设备、输出设备

### 运算器
算术运算 和 逻辑运算，称为`ALU`(算数逻辑运算部件)
参与运算的数是`二进制`的
数的位数越多，计算的精度就越高
位数越多，所需电子器件也越多，一般8位、16位、32位、64位
{% asset_img ALU.png%}

### 存储器
通常，在存储器中把保存一个数的若干个触发器称为一个`存储单元`，`存储器是由许多存储单元组成的`

每个存储单元都有编号，称为`地址`

向存储器中存数或者从存储器中取数，都要按给定的地址来寻找所选的存储单元。

存储器所有存储单元的总数称为存储器的`存储容量`，通常用单位KB，MB，GB，TB等来表示，如64KB，128MB。

存储容量越大，表示计算机记忆储存的信息就越多。

半导体存储器的存储容量毕竟有限，因此计算机中又配备了存储容量更大的磁盘存储器和光盘存储器，称为外存储器，简称`外存`

相对而言，半导体存储器称为内存储器，简称`内存`

### 控制器
#### 指令的形式
指令由两部分组成：`操作的性质`（操作码）和`操作数的地址 `（地址码）。

计算机的`所有指令`构成该计算机的`指令系统`，指令系统不仅是`硬件设计的依据`，而且是`软件设计的基础`，是衡量计算机性能的一个重要指标。

指令的`操作码`和`地址码`都用`二进制代码`来表示。`操作码需要编码，而地址码则不需要`。

存储器的任何位置可以存放数据，也可以存放指令，一般将指令和数据分开存放。

将解题的程序（指令序列）存放到存储器中称为`存储程序`，而控制器依据存储的程序来控制全机协调完成计算任务称为`程序控制`。

`指令和数据放在同一个存储器中，存储程序并按地址顺序执行`，这就是冯·诺依曼型计算机的体系结构。

如果指令和数据分别放在两个存储器中，称为`哈佛结构`。

**冯·诺依曼结构的主要思想**
1. 计算机应由运算器、控制器、存储器、输入设备和输出设备五个基本部件组成。
2. 各基本部件的功能是：
```
存储器不仅能存放数据，而且也能存放指令，形式上两者没有区别，但计算机应能区分数据还是指令；
控制器应能自动取出指令来执行；
运算器应能进行加/减/乘/除四种基本算术运算，并且也能进行一些逻辑运算和附加运算；
操作人员可以通过输入设备、输出设备和主机进行通信。
```
3. 内部以二进制表示指令和数据。每条指令由操作码和地址码两部分组成。操作码指出操作类型，地址码指出操作数的地址。由一串指令组成程序。
4. 采用“存储程序”工作方式。

#### 控制器的基本任务
`按照计算程序所排的指令序列`，先从存储器`取出一条指令放到控制器中`，对`该指令的操作码由译码器进行分析判别`，然后根据指令性质，`执行这条指令`，进行相应的操作。

接着从存储器取出第二条指令，再执行这第二条指令。依次类推。

通常把取指令的一段时间称为取指周期，而把执行指令的一段时间称为执行周期。

`控制器反复交替处于取指周期和执行周期之中。`

每取出一条指令，`控制器中的指令计数器加1，为取下一条指令做好准备`，因此指令需要顺序存放。

`运算器和控制器合称中央处理器`，简称`CPU`。

#### 指令流和数据流
指令和数据统统放在内存中，从形式上看，它们都是二进制数码，但是控制器可以区分开哪些是指令，哪些是数据。

`取指周期中`从内存读出的信息流是指令流，流向控制器；而在`执行器周期中`从内存读出的信息流是数据流，由内存流向运算器。

计算机按照指令流和数据流可以分为：
```
单指令流单数据流（SISD），即传统的冯·诺依曼体系结构。
单指令流多数据流（SIMD），包括阵列处理机和向量处理器系统。
多指令流单数据流（MISD），实际上不存在。
多指令流多数据流（MIMD），包括多处理器和多计算机系统
```

### 适配器与输入输出设备
计算机的输入输出设备通常称为`外围设备`
`适配器`：使得被连接的`外围设备通过系统总线与主机进行联系`，以便使主机和外围设备并行协调地工作 。

`系统总线`：构成计算机系统的骨架，是`多个系统部件之间进行数据传送的公共通路`
{% asset_img 计算机框架.png%}
{% asset_img 计算机系统.png%}

多总线计算机系统结构
{% asset_img 多总线计算机系统.png%}
CPU中包含`控制器`、`算术逻辑部件ALU`、`通用寄存器组`、`总线接口部件`等。

CPU、主存和I/O模块之间`通过总线`交换信息：`处理器总线`用来传输与CPU交换的信息；`存储器总线`用来传输与主存交换的信息；`I/O总线`用来传输与设备控制器交换的信息，不同总线之间通过`I/O桥接器`相连。


## 计算机软件
1. 系统软件：用来简化程序设计，简化使用方法，提高计算机的使用效率，发挥和扩大计算机的功能及用途，包括以下四类：
```
各种服务性程序，如诊断程序、排错程序、练习程序等
语言程序，如汇编程序、编译程序、解释程序等
操作系统
数据库管理系统
```
2. 应用软件：用户利用计算机来解决某些问题而编制的程序，如工程设计程序、数据处理程序、自动控制程序、企业管理程序、情报检索程序、科学计算程序等。

## 计算机系统的层次结构
### 多级组成的计算机系统
第一级：微程序设计级，由机器硬件直接执行微指令，硬件级
第二级：一般机器级，微程序解释机器指令系统，硬件级
第三级：操作系统级，由操作系统程序实现，混合级
第四级：汇编语言级，由汇编程序支持和执行
第五级：高级语言级，由各种高级语言编译程序支持和执行
{% asset_img 计算机系统层次结构.png%}
功能转换：上层是下层的`抽象`，下层是上层的`实现`，底层为上层提供`支撑环境`！

### 软件和硬件的逻辑等价性
随着大规模集成电路技术的发展和软件硬化的趋势，计算机系统的软、硬件界限已经变得模糊了。

因为任何操作可以由软件来实现，也可以由硬件来实现；任何指令的执行可以由硬件完成，也可以由软件来完成。

对于某一机器功能采用硬件方案还是软件方案，应考虑各个方面的因素：价格、速度、可靠性、存储容量、变更周期等。

实体硬件机功能扩大：将一些原来通过编制程序实现的操作，比如说整数乘除法指令、浮点运算指令、处理字符串指令等，改为直接由硬件完成。

固件的概念（功能上是软件，形态上是硬件）：使用容量大、体积小、价格低、可以改写的只读存储器将许多复杂的、常用的程序制作成固件。


# 运算方法和运算器
## 数值型数据的表示方法
### 进位计数制
基数 和 权值W
#### 常用进制
2，8，10，16进制
#### 进制转换
除2取余、乘2取整、按权相加、逐位转换/分组转换

### 带符号数的表示
`0`表示正号`+`，`1`表示负号`-`
二进制数的码制：原码、反码、补码、移码

#### 原码
一个二进制数，0-1代码表示符号，数值位不变
真值：+1001010  -1001010
原码：01001010  11001010

字长8位的原码，表示范围：`-127~+127`
[+127]原=0 0000000
[-127]原=1 0000000
数值`0`有两种原码形式：
[+0]原=0 0000000
[-0]原=1 0000000

#### 反码
正数情况：
X反=X原(X>=0)
例：X=+1101001(真值+105) X反=X原=0 1101001

负数情况：
符号位保持为`1`，数值位分别`按位取反`
例：X=-1101001(真值-105) X原=1 1101001 X反=1 0010110

字长为8位的反码，表示范围：`-127~+127`
[+127]反=0 1111111
[-127]反=1 000000
数值`0`也有两种反码形式：
[+0]反=0 0000000
[-0]反=1 1111111

#### 补码
编码定义：[X]补=X+2^n(模2^n)，n为编码位数
**编码规则**
对于正数：
[X]补=[X]原

对于负数：
符号位仍保持为`1`，其余各数值位`按位取反，末位+1`
[X]补=[X]反+……1

字长8位的补码，表示范围：`-128~+127`
[+127]补=0 1111111
[-128]补=1 0000000

注意：补码比原码和反码多表示一个负值，即-128
数值`0`只有一种补码形式
[+0]补=[-0]补=0 0000000

#### 原码与补码之间的转换
##### 已知[X]原，求[X]补
正数：[X]补=[X]原
负数：符号位仍保持为`1`，其余各数值位`按位取反，末位+1`，[X]补=[X]反+……1

##### 已知[X]补，求[X]原
[[X]补]补=[X]原

##### 求补(变补)，即已知[X]补，求[-X]补
[X]补的代码连同符号位一起变反，末位再加一

#### 移(增)码
移码通常用于表示浮点数的阶码
阶码一般为整数，所以移码通常只用于表示整数
[X]移=2^(n-1)+x，其中-2^(n-1)<X<2^(n-1)，这里的n为`X原`位数
上述规则等价于将X正向平移或者增加2^(n-1)

正数：将原码符号位变反
负数：将原码连同符号位一起变反，末位+1

补码和移码：符号相反、数值位相同


### 定点数与浮点数
#### 定点数的表示
数的小数点固定在同一位置不变
##### 带符号的定点小数
{% asset_img 带符号定点小数.png%}
字长`n+1`位，表示范围：`-(1-2^(-n))~1-2^(-n)`

##### 带符号的定点整数
{% asset_img 带符号定点整数.png%}
字长`n+1`位，则数的表示范围为：`-(2^n-1)~2^n-1`


##### 无符号定点整数
小数点的位置固定在最低数值位之后
表示范围：`0~(2^(n+1)-1)`；分辨率为：1

#### 浮点数的表示原理
##### 浮点表示中，小数点的位置可按需浮动
{% asset_img 浮点数格式模型.png%}
##### 引入浮点数表示的意义
相同字长时，浮点数的表示范围更大、精度更高！

##### 浮点数的机器(存储)格式
{% asset_img 浮点数机器格式.png%}

##### 尾数M的规格化表示
目的：使浮点数的表示代码“唯一”
**浮点数用原码表示**
1/2<=|M|<1
**浮点数用补码表示**
-1<=M<-1/2 或 1/2<=M<1

对于原码：规格化以后尾数的最高有效位为`1`
对于补码：正数，规格化以后最高数值位为`1`；负数，规格化以后最高数值位为`0`

#### IEE754格式的浮点数
32位 和 64位
{% asset_img 32位单精度.png%}
{% asset_img 64位双精度.png%}
补充说明：
{% asset_img 补充说明.png%}

## 字符型数据
### ASCII码
字符总数：128(0-9，大小写英文字母，运算符，标点符号，标示符，格式控制符等)
代码宽度：7b
存储宽度：7b(有效位)+1b(奇偶校验位)=8b
### 汉字编码

## 数据处理与存储
### 移位操作
#### 逻辑移位
数码位置变化
{% asset_img 逻辑移位.png%}
#### 算术移位
符号位不变、数码位置变化
{% asset_img 算术移位.png%}

**正数补码\原码移位规则**
移位规则：
数符不变(单：符号位不变；双：第一符号位不变)
空位补0(右移时第二符号位移至尾数最高位)
{% asset_img 补码原码移位规则.png%}

**负数补码移位**
移位规则：
数符不变(单：符号位不变；双：第一符号位不变)
左移空位补0，右移空位补1(第二符号位移至尾数最高位)
{% asset_img 负数补码移位规则.png%}

### 舍入方法
#### 0舍1入(原码、补码)
#### 末位恒置1

### 数位扩展与压缩
#### 符号扩展
直接把符号位(0/1)填充到扩展位
#### 0-扩展
高位均全补0(针对无符号数)
#### 位数压缩 弃高位、留低位

### 数据存储(按字节编址)
#### 小端模式/Little-Endian
小地址单元存储数据的地位(即尾端)
#### 大端模式/Big-Endian
大地址单元存储数据的地位(即尾端)


### 数据字的对齐
要求数据的地址是相应的边界地址


## 定点加法、减法运算
### 补码加法
#### 原码加/减法运算
`加法规则：`
先判符号位，若相同，绝对值相加，结果符号不变；若不同，则作减法，|大| - |小|，结果符号与|大|相同。

`减法规则：`
两个原码表示的数相减，首先将减数符号取反，然后将被减数与符号取反后的减数按原码加法进行运算。

#### 补码加法运算
补码加法的公式：
`[x]补＋[y]补＝[x＋y]补  (mod 2)`

特点：
1. 不需要事先判断符号，符号位与码值位一起参加运算。
2. 在模2n+1的意义下相加，即大于2n+1的进位要丢掉。

在模2意义下，`任意两数的补码之和等于该两数之和的补码`。
这是补码加法的理论基础，该公式既适用于定点整数，也适用于定点小数。

### 补码减法
补码减法运算的公式：
`[x－y]补＝[x]补－[y]补＝[x]补＋[-y]补`

### 溢出概念及检测方法
概念与分析：
上溢：两个正数相加，结果大于机器字长所能表示的最大正数，称为正溢
下溢：两个负数相加，结果小于机器字长所能表示的最小负数，称为负溢

溢出的检测方法：
1. 单符号位法(无实际应用价值)
2. 双符号位法(补码变形)(模4补码)

`采用变形补码后数的表示`：
任何小于1的正数： 两个符号位都是“0”，即 00.x1x2...xn;
任何大于-1的负数：两个符号位都是“1”，即 11.x1x2…xn

`两数变形补码之和等于两数和的变形补码`，要求：
两个符号位都看做数码一样参加运算；
两数进行以4为模的加法，最高符号位上产生的进位要丢掉

双符号位的含义如下：
```
00         结果为正数，无溢出
01         结果正溢
10         结果负溢
11         结果为负数，无溢出
```
即：结果的两个符号位的代码不一致时，表示溢出；两个符号位的代码一致时，表示没有溢出。
**不管溢出与否，最高符号位永远表示结果的正确符号**
溢出逻辑表达式为：`V＝Sf1⊕Sf2`

3. 利用进位值的判别法----加法器中实际使用的方法

### 基本的二进制加法/减法器
#### 一位全加器
加法运算：
`Ai+Bi+Ci=Si  (Ci+1)`
{% asset_img 一位全加器真值表.png%}
逻辑方程：`Si=Ai异或Bi异或Ci`; `Ci+1=AiBi+BiCi+CiAi=AiBi+(Ai异或Bi)Ci`

一位全加器逻辑符号
{% asset_img 一位全加器逻辑符号.png%}

一位全加器逻辑电路图
{% asset_img 一位全加器逻辑电路图.png%}

#### n位的行波进位加减器
n个1位的全加器(FA)可级联成一个n位的行波进位加减器
{% asset_img n位的行波进位加减器.png%}

#### n位行波进位加法器的时间延迟
`T被定义为相应于单级逻辑电路的单位门延迟。`
T通常采用一个`“与非”`门或一个`“或非”`门的时间延迟来作为度量单位。

典型门电路延迟时间：
```
与非门：T
或非门：T
非门：T
与门：2T
或门：2T
异或门：3T
异或非门：3T
接线逻辑(与或非)：T+TRC
```
1. 对于一位全加器FA来说，Si时间延迟为6T(每级异或门延迟3T)；Ci+1的时间延迟为5T。
2. n位行波进位加法器的延迟时间ta为：
  9T为最低位上的两极“异或”门再加上溢出“异或”门的总时间；
  2T为每级进位链的延迟时间

  考虑溢出检测时，有：ta＝n·2T＋9T＝(2n＋9)T
  当不考虑溢出检测时，有：ta＝(n-1)·2T＋6T　

  ta为在加法器的输入端输入加数和被加数后，在最坏的情况下加法器输出端得到稳定的求和输出所需要的最长时间


## 定点乘法运算
### 原码乘法
#### 乘法的手工算法
符号位异或，其余正常乘法
乘积符号的运算规则：`同号相乘为正，异号相乘为负`

#### 原码一位乘法   ？？？
**特点**：每次只需要相加两个数，然后右移一位。相加的两个数（部分积和位积）都只有n位，因而不需要2n位的加法器
{% asset_img 原码一位乘法.png%}
原码一位乘法流程图
{% asset_img 原码一位乘法流程图.png%}

**阵列乘法器**
`串行加法器`的`优劣`分析
1. 不需要很多器件，硬件结构简单；
2. 速度太慢，执行一次乘法操作的时间至少是加法操作的n倍；

`不带符号`的`阵列乘法器`

### 补码乘法
`原码一位乘的缺点`
1. 原码一位乘法的主要问题是：符号位不能参与运算。
2. 而补码乘法可以实现符号位直接参与运算。

`补码一位乘法`又称`Booth算法`
1. 真值与补码之间的关系
{% asset_img 真值与补码的关系.png%}
2. 补码的右移
在补码机器中，一个数不论其正负，连同符号位向右移一位，符号位保持不变，就等于乘1/2
`[1/2x]补 = x0.x0x1x2…xn`，要得到[2^(-i)x]补，连同符号位右移`i`位即可。
3. 补码乘法规则
被乘数  [x]补 = x0.x1x2…xn；乘数  [y]补 = y0.y1y2…yn；
补码乘法算式：`[x·y]补 = [x]补· y`或`[x·y]补 = [x]补·[−𝑦0+∑(𝑖=1)(𝑛)[𝑦𝑖·2^(−𝑖)]`
4. 补码一位乘的运算规则
```
如果 yn=yn+1 ，则部分积 [zi] 加0，再右移一位；
如果 ynyn+1=01 ，则部分积 [zi] 加[x]补，再右移一位；
如果 ynyn+1=10 ，则部分积 [zi] 加[-x]补,  再右移一位；
如此重复n + 1步，但最后一步不移位。
包括一位符号位，所得乘积为2n+1位，其中n为尾数位数。
```
5. 算法流程图
{% asset_img 补码一位乘法流程图.png%}

`Booth 4基乘法算法`  如：A·B   ？？？

## 定点除法运算
### 原码一位除法
被除数 x，其原码为`[x]原＝xf.xn-1… x1x0`
除数 y，其原码为`[y]原＝yf.yn-1… y1y0 `
则有商q＝ｘ/ｙ,其原码为`[q]原＝(xf⊕yf)+(0.xn-1…x1x0/0.yn-1… y1y0)`

商的符号运算`qf＝xf⊕yf`与原码乘法一样
1. 手算运算步骤
仿十进制除法运算
2. 机器运算与手算的不同
在计算机中，小数点是固定的，不能简单地采用手算的办法。为便于机器操作，除数Y固定不变，被除数和余数进行左移相当于乘2）。

机器不会心算，必须先作减法：
若余数为正，才知道够减；
若余数为负，才知道不够减。不够减时必须恢复原来的余数，以便再继续往下运算。这种方法称为`恢复余数法`

要恢复原来的余数，只要当前的余数加上除数即可。但由于要恢复余数，使除法进行过程的步数不固定, 因此控制比较复杂。  

3. 加减交替法
由于恢复余数法的步数不固定，控制比较复杂，实际上常用的是`加减交替法`

**特点**：当运算过程中出现不够减的情况，不必恢复余数，而是根据余数的符号，继续往下运算，因此步数固定，控制简单

运算规则：
```
    当余数为正时，商1，余数左移一位，减除数；
    当余数为负时，商0，余数左移一位，加除数。
```


### 补码一位除法
被除数、除数用补码表示，符号位和数值位一起参与运算，商的符号位与数值位由统一的算法求得：
```
若被除数与除数同号，被除数减去除数；
若被除数与除数异号，被除数加上除数。

余数和除数同号，商1，余数左移一位，下次减除数；
余数和除数异号，商0，余数左移一位，下次加除数。

重复步骤上一步，连同符号位在内，共做n+1步。
```
商的校正
算法是在商的末位“恒置1”的舍入条件下推导的，故此算法存在误差，这样引起的最大误差是2-n。在对计算精度没有特殊要求的情况下，一般就采用商的末位“恒置1”的办法，这样操作比较简单，而且易于实现

进一步提高商的精度
1. 刚好能除尽时，若除数为正，商不必校正；若除数为负，则商加2-n。
2. 如不能除尽时，若商为正，则不必校正；若商为负，则商加2-n。

### 并行除法器



## 定点运算器的组成
### 逻辑运算
按位非、按位或、按位与、按位异或等

### 多功能算术/逻辑运算单元（ALU）
由一位全加器（FA）构成的行波进位加法器存在的问题：
1. 串行进位，它的运算时间长；
2. 只能完成加法和减法两种操作而不能完成逻辑操作。

多功能算术/逻辑运算单元（ALU）：
1. 不仅具有多种算术运算和逻辑运算的功能；
2. 而且具有先行进位逻辑。
从而能实现高速运算

一位全加器逻辑表达式：
{% asset_img 一位全加器逻辑表达式.png%}
`Fi＝Xi⊕Yi⊕Cn+i`        `Cn+i+1＝XiYi+YiCn+i+Cn+iXi`
将Ai和Bi先组合成由控制参数S0、S1、S2、S3控制的组合函数Xi和Yi，作为一位全加器的输入。
这样不同的控制参数可以得到不同的组合函数，从而能够实现多种算术运算和逻辑运算
{% asset_img 组合函数实现运算.png%}

### 内部总线
计算机内部各部件之间数据传送频繁，为了`减少内部数据传送线`并`便于控制`，通常将`寄存器间的数据传送通路`加以`归并`，组成`总线结构`，使不同来源的信息在此传输线上`分时传送`。

按`总线所处的位置`分：
1. 内部总线（CPU内）
2. 外部总线（系统总线——CPU与存储器、I/O系统之间的数据传送通路）

按`总线的逻辑结构`分：
1. 单向传送总线
2. 双向传送总线（带缓冲器、带锁存器）

### 定点运算器的基本结构
`运算器`包括`ALU`、`阵列乘除器`、`寄存器`、`多路开关`、`三态缓冲器`、`数据总线`等逻辑部件。

运算器的设计主要围绕ALU和寄存器同数据总线之间`如何传送操作数和运算结果`。
#### 单总线结构的运算器
{% asset_img 单总线结构的运算器.png%}
同一时间内，只能有一个操作数出现在总线上。
为了把两个操作数输入到ALU，需要分两次传送，因此需要A、B两个缓冲寄存器
只有两个操作数同时出现在ALU的两个输入端，ALU才执行加法

`缺点`：操作速度较慢

#### 双总线结构的运算器
{% asset_img 双总线结构的运算器.png%}
两条总线各自把其数据送至ALU的输入端
专用寄存器分成两组，分别与一条总线交换数据
ALU的输出不能直接加到总线上去：当形成操作结果的输出时，两条总线都被输入数据占据，因此必须设置缓冲寄存器

#### 三总线结构的运算器
{% asset_img 三总线结构的运算器.png%}
ALU的两个输入端分别连接两条总线，而ALU的输出与第三条总线相连。
算术逻辑操作可以在一步的控制之内完成。
设置了总线旁路器，如果一个操作数不需要修改，可以直接从总线2传送到总线3。

`特点`：操作速度快

## 浮点运算方法和浮点运算器
### 浮点加、减法运算
{% asset_img 浮点加减法运算.png%}
1. 浮点加减运算大致步骤：
```
第一步：0操作数检查；
第二步：比较阶码大小并完成对阶；
第三步：尾数进行加或减运算；
最后：结果规格化并进行舍入和溢出处理
```
2. 浮点加减法运算电路

### 浮点乘、除法运算
1. 浮点乘法、除法运算规则
{% asset_img 浮点乘除法运算规则.png%}

2. 浮点乘、除法运算步骤
浮点数的乘除运算大体分为六步：第一步，0 操作数检查，如果被除数x为0，则商为0，如果除数y为0，则商为∞；第二步，阶码加/减操作；第三步，尾数乘/除操作；第四步，结果规格化；第五步，舍入处理；第六步，确定积的符号。

1）浮点数的阶码运算
对阶码的运算有＋1、－1、两阶码求和、两阶码求差四种，运算时还必须检查结果是否溢出。

2）尾数处理——尾数用原码表示：
 ① 只要尾数最低位为1，或移出的几位中有为1的数值位，就使最低位的值为1；
 ② 0舍1入，即当丢失的最高位的值为1时，把这个1加到最低数值位上进行修正。


# 多层次的存储器
## 存储器概述
全机中心地位
`存储器`：是计算机系统中的记忆设备，用来存放程序和数据。
`存储元`：存储器的最小组成单位，用以存储1位二进制代码。
`存储单元`：是CPU访问存储器基本单位，由若干个具有相同操作属性的存储元组成。
`单元地址`：在存储器中用以表识存储单元的唯一编号，CPU通过该编号访问相应的存储单元。
`字存储单元`：存放一个字的存储单元，相应的单元地址叫字地址
`字节存储单元`：存放一个字节的存储单元，相应的单元地址叫字节地址。
`按字寻址计算机`：可编址的最小单位是字存储单元的计算机
`按字节寻址计算机`：可编址的最小单位是字节的计算机。
`存储体`：存储单元的集合，是存放二进制信息的地方

存储器各个概念之间的关系（按字节寻址）
{% asset_img 存储器各个概念之间的关系.png%}

### 存储器分类
按`存储介质`分：
1. `半导体存储器`(双极型 TTL：高速；MOS：高集成度，制造简单，成本低廉，功耗小
) 易失
2. `磁表面存储器`：磁盘、磁带等 非易失
3. `光盘存储器`：用激光在记录介质上进行读写，记录密度高、耐性好、可靠性高、可互换性强 非易失

按`存取方式`分：
1. `随机存储器`：任何存储单元的内容都能被随机存取，且存取时间和存储单元的物理位置无关——如半导体存储器。
2. `顺序存储器`：只能按某种顺序来存取，存取时间和存储单元的物理位置有关——如磁带存储器

按`存储器的读写功能`分：
1. `只读存储器（ROM）`：存储的内容是固定不变的，只能读出而不能写入的半导体存储器。(通常用来存放固定不变的程序、常数和汉字字库，甚至用于操作系统的固化。也可以作为控制存储器，存放微程序。早期采用掩模工艺，把原始信息记录在芯片中，一旦制成就无法改变)
2. `随机读写存储器（RAM）`：既能读出又能写入的半导体存储器，分为静态RAM（SRAM）和动态RAM（DRAM）。

按`信息的易失性`分 ：
1. `易失性存储器`：断电后信息消失的存储器——如RAM。
2. `非易失性存储器`：断电后仍能保存信息的存储器——如磁盘、光盘等。

按在`计算机系统中的作用`分：
1. `主存储器`、`辅助存储器`、`高速缓冲存储器`、`控制存储器`等。

{% asset_img 半导体存储类型.png%}

### 存储器的分级
要求：容量大，速度快，成本低
采用多级存储器体系结构，即使用`高速缓冲存储器`、`主存储器`和`外存储器(辅存)`

`内存储器（内存）`：CPU能直接访问的存储器，包括`cache`和`主存储器`

`外存储器（外存）`：主板外的存储器。
外存的信息必须调入内存后才能被CPU处理。
{% asset_img 存储器分级.png%}

`高速缓冲存储器`：简称`cache`，高速存取指令和数据，存取速度快，单存储容量小
`主存储器`：简称`主存`，存放计算机运行期间的大量程序和数据，存取速度较快，存储容量不大
`外存储器`：简称`外存`，存放系统程序和大型数据文件及数据库，存储容量大，位成本低，速度慢，信息调入内存后才能被CPU处理
{% asset_img 存储器存取时间.png%}

**内存与外存的关系及比较**
{% asset_img 内存与外存关系及比较.png%}

### 主存储器的技术指标
`存储容量`：所包含的存储单元的总数（单位：MB或GB）
`存取时间（存储器访问时间）`：一次读操作命令发出到该操作完成，将数据读出到数据总线上所经历的时间，通常取写操作时间等于读操作时间
`存储周期`：连续启动两次读操作所需间隔的最小时间，`略大于存取时间`。存储周期等于存取时间加上下一次存取开始前所要求的附加时间，因为存储器由于读出放大器、驱动电路等都有一段稳定恢复时间，所以读出后不能立即进行下一次访问
`存储器带宽`：单位时间里存储器所存取的信息量，通常`B/s`作为度量单位，是衡量数据`传输速率`的重要技术指标


## SRAM存储器
### 基本的静态存储元阵列
SRAM基本存储元采用`触发器原理`，数据保存在一对`正负反馈门电路`中，`只要供电，数据就一直保持`。

`不是破环性读出`，信息读出后仍保持原状态，`不需要重写，即无需刷新`！

电源掉电时，原存信息丢失，属于`易失性`半导体存储器。

任何一个SRAM，都有三组信号线：
1. `地址线`：图中共有6条地址线A5～A0，决定了存储器的容量是26=64个存储单元。
2. `数据线`：图中共有4条数据线I/O3～I/O0，决定了存储器的字长是4位。
3. `控制线`：R/"W"  ̅指定了对存储器进行读（高电平）还是写（低电平）。
{% asset_img 静态存储元阵列.png%}

### 基本的SRAM逻辑结构
一个SRAM存储器由`存储体`、`读写电路`、`地址译码电路`和`控制电路`等组成

`存储体`：将基本的存储电路有规则地组织起来，就是存储体

SRAM芯片采用二级译码：即双译码方式
将地址分成x向、y向两部分，第一级进行x向（行译码）和y向（列译码）的独立译码，然后在存储阵列中完成第二级的交叉译码。

### 存储器的读写周期
`读出时间`：从给出有效地址到外部数据总线上稳定地出现所读出的数据信息所经历的时间。t(AO)
`读周期时间`：则是存储器进行两次连续读操作时所必须间隔的时间，它总是大于或等于读出时间。t(RC)>=t(AO)

t(WC)时间称为`写周期时间`。为了控制方便，一般取`读周期时间等于写周期时间`，通常称为`存储周期`（存取周期）


## DRAM存储器
### DRAM存储元
靠`电容存储电荷的原理`存储信息，电容上的电荷一般只能维持1～2ms，因此即使电源不掉电，信息也会自动消失。
与SRAM相比`集成度更高`，`功耗更低`，`用于构建主存储器`。


### DRAM芯片的逻辑结构
{% asset_img DRAM芯片的逻辑.png%}
两个电源脚，两个地线脚，一个空脚（NC）。
A0 ~ A10：地址输入线；
`RAS非`：行地址选通信号线，兼起片选信号作用（整个读写周期， `RAS非` 一直处于有效状态）；
`CAS非`：列地址选通信号线；
WE：写控制信号 ；
OE：读控制信号；
D1 ~ D4：数据输入/输出线。

### DRAM读写周期、刷新周期
1. 读周期时序
地址总线上行地址有效 → 行选通信号("RAS" ) ̅有效，行地址被打入行地址锁存器 → 地址总线上列地址有效 → 列选通信号("CAS" ) ̅有效，列地址被打入列地址锁存器 → 读命令有效 → 数据输出
2. 写周期时序
地址总线上行地址有效 → 行选通信号("RAS" ) ̅有效，行地址被打入行地址锁存器 → 地址总线上列地址有效 → 列选通信号("CAS" ) ̅有效，列地址被打入列地址锁存器 → 写命令有效 → 数据总线上输入数据有效

`读周期`、`写周期`的定义是从行选通信号`RAS非` ̅下降沿开始，到下一个`RAS非`号的下降沿为止的时间，也就是连续两个读周期的时间间隔
3. 刷新周期
集中式刷新、分散式刷新

### 存储器容量的扩充
通常选用`ROM`芯片存放`系统程序`，选用`RAM`芯片存放`用户程序`

存储芯片容量可表示为：2^n×m位/片
2^n：存储芯片字数，需要n根地址总线
m位：存储芯片字长，需要m根数据总线

**字和位扩展**
扩展时所需芯片数：d = "设计要求的存储器容量"/"已知芯片存储容量" 

#### 位扩展
只加大字长，而存储器的字数与存储芯片字数一致，对芯片没有片选要求

例1：用8k×1位的存储芯片组成8k×8位的存储器需`8片`芯片
地址总线 —— 需要 13 根          
数据总线 —— 共需 8 根              


#### 字扩展
仅在字数方向扩展，而字长不变

例2：用16Kx8位的存储芯片组成64Kx8位的存储器需`4片`芯片
地址总线 —— 共需16根
数据总线 —— 需要8根

#### 字位扩展
在字数方向和字长方向上同时扩展。

例3：用1Kx4位的存储芯片组成4Kx8位的存储器需`8片`芯片
地址总线 —— 共需12根
数据总线 —— 共需8根

**总结**
DRAM和SRAM的比较
优点：
1. 在同样大小的芯片中，DRAM的集成度远高于SRAM
2. DRAM行、列地址分时传送，减少了芯片引脚，封装尺寸也减少
3. DRAM的价格比SRAM便宜

缺点：
1. 由于使用动态元件（电容），速度比SRAM慢。
2. DRAM需要再生，故需配置再生电路，也需要消耗一部分的功率

容量不大的`高速缓冲存储器`大多用SRAM实现


## 只读存储器和闪速存储器
### 只读存储器
{% asset_img 只读存储器.png%}

### 闪速存储器
#### 闪速存储器
又称：快擦型存储器
新型的、具有性价比更好、可靠性更高的可擦除非易失性存储器

既有EPROM价格便宜、集成度高的优点，又有EEPROM电可擦除重写的特性，能够整片擦除

闪速存储器是一种高密度、非易失性的读/写存储器，它突破了传统的存储器体系，改善了现有存储器的特性

特点：
```
是E2PROM的演进，本质上还是属于E2PROM；
廉价的高密度——具有巨大比特数目的存储容量；
属于非易失性存储器，适合长期保存信息；
能快速擦写，写入前必须先擦除，因此写比读要慢；
存储器访问周期短、功耗低；
现在常用的SSD固态硬盘是由Flash芯片组成的
```
#### 固态硬盘(SSD)
又称：电子硬盘
使用闪存组成的外部存储系统，与U盘并没有本质差别，只是容量更大，存取性能更好

用闪存颗粒代替了磁盘作为存储介质，利用闪存的特点，以区块写入和抹除的方式进行数据的读取和写入

特点：
```
写操作比读操作慢得多
电信号的控制使得固态硬盘的内部传输速率远远高于常规硬盘
其接口规范和定义、功能及使用方法与传统硬盘完全相同，在产品外形和尺寸上也与普通硬盘一致。目前接口标准上使用USB、SATA和IDE，因此SSD是通过标准磁盘接口与I/O总线互连的
在SSD中有一个闪存翻译层，它将来自CPU的逻辑磁盘块读写请求翻译成对底层SSD物理设备的读写控制信号。因此，这个闪存翻译层相当于磁盘控制器。
闪存的擦写次数有限，所以频繁擦写会降低其写入使用寿命
```

#### 各种存储器性能比较
{% asset_img 各种存储器性能比较.png%}

## 并行存储器
采取一些加速CPU和存储器之间有效传输的特殊措施：
`芯片技术`：研究开发高性能芯片
`结构技术`：
```
采用空间并行操作方式　　　            ——双端口存储器　
提高时间读出并行性                            ——多模块交叉存储器
牺牲硬件来缩短主存储器的读出时间   ——相联存储器
```
### 双端口存储器
同一个存储器具有`两组相互独立的读写控制线路`，是一种高速工作的存储器。

当两个端口的地址不相同时，在两个端口上进行读写操作，一定不会发生冲突。
当两个端口同时存取存储器同一存储单元时，便发生读写冲突。
为解决读写冲突问题，设置`BUSY非`标志

### 多模块交叉存储器
大存储器在一个存储周期中读出的不是一个存储单元的w位信息，而是n个字，这样在单位时间里存储器提供的信息量可提高n倍，这样组织的主存系统称为`并行主存系统`

#### 存储器的模块化组织
一个由若干个模块组成的主存储器是线性编址的。这些地址在各模块中有两种安排方式：`顺序方式`、`交叉方式`

**顺序方式**
各模块一个接一个串行工作。某个模块进行存取时，其他模块不工作。
优点：
某一模块出现故障时，其他模块可以照常工作
通过增添模块来扩充存储器容量比较方便

缺点：
各模块串行工作，存储器的带宽受到了限制

**交叉方式**
连续地址分布在相邻的不同模块内。同一个模块内的地址都是不连续的。
对连续字的成块传送可实现多模块流水式并行存取，大大提高存储器的带宽

#### 多模块交叉存储器的基本结构

### 相联存储器
#### 相联存储器的基本原理
相联存储器不是按地址访问的存储器，而是按内容寻址的存储器。

相联存储器是指其中任一存储项内容作为地址来存取的存储器

选用来寻址存储器的子段叫做`关键字`，简称`“键”`

相联存储器的基本原理是把存储单元所存内容的某一部分作为检索项（即关键字项），去检索该存储器，并将存储器中与该检索项符合的存储单元内容进行读出或写入

格式：
`KEY，DATA`
KEY是地址，DATA是被读写信息

#### 相联存储器举例
`SRR为查找结果寄存器`

在计算机系统中，相联存储器主要用于虚拟存储器中存放分段表、页表和快表；在高速缓冲存储器中，相联存储器作为存放cache的行地址之用

## cache存储器
### 存储体系
`存储体系`：把各种不同存储容量、不同存取速度、不同价格的存储器，组成层次结构，并通过管理软件和辅助硬件将不同性能的存储器组合成有机的整体，称为计算机的存储层次或存储体系
{% asset_img 存储体系.png%}
在任何指定时间，**数据只能在相邻的两级之间拷贝**

#### 存储体系的实现原理：程序访问的局部性原理
CPU访问存储器时，无论是取指令还是存取数据，所访问的存储单元都趋于聚集在一个较小的连续区域中。
这种对局部范围的存储器地址频繁访问，而对此范围以外的地址则访问甚少的现象就称为`程序访问的局部性原理`

`时间局部性`：如果一个信息项正在被访问，那么在近期它很可能还会被再次访问。（程序循环、堆栈）
`空间局部性`：在最近的将来将用到的信息很可能与现在正在使用的信息在空间地址上是临近的。（指令顺序执行、数组存放）

`程序访问的局部性原理主要表现：`
程序`地址的分布是连续`的，加上循环程序段和子程序段要重复执行多次，因此，对程序地址的访问具有`相对集中的倾向`。
数据分布的这种集中倾向不如指令明显，但对数组的存储和访问以及工作单元的选择都可以使存储器地址相对集中。

`其它原因：`
在高速机器中，信号传输是延迟的一个重要原因。而大的存储器因地址译码级数多，信号延迟会更大。
相同器件条件下，`小容量存储器比大容量存储器快`。
`容量小、离CPU近的高速存储器存放最近要访问的数据`。
优先考虑最近经常被访问的代码。

#### 存储体系的特点
1. 包含性
所有信息项最初存放在最外层Mn，在处理过程中，它的子集复制到Mn-1，同样， Mn-1的子集复制到Mn-2，……
如果在Mi中找到一个信息字，那么同一个字的复制品在所有的高层Mi+1，Mi+2，……，Mn中都一定可以找到
2. 相邻层之间的数据传送单位
    CPU         <-> 高速缓存：字    假设：[1个字包含4个字节]
    高速缓存 <-> 主存储器：块                [每块32个字节（8个字）]
    主存         <-> 磁盘：        页面            [每页4K字节，包含128块]
    磁盘         <-> 磁带：        段
{% asset_img 相邻层之间的数据传送.png%}

#### 存储体系的性能
`命中`：在Mi中找到一个信息项时，称之为命中，反之称为失效
`命中率`：在Mi层的命中率hi是信息项可在Mi中找到的概率。
`失效率`：在Mi中的失效率定义为1-hi
`相继层的命中率`是存储器容量、管理策略和程序行为的函数，它是独立的随机变量，其值在0到1之间

对Mi的`访问频率fi`是指在较低层次有i-1次失效而在Mi有一次命中时访问Mi成功的概率
                     `fi = (1-h1)·(1-h2)···(1-h(i-1))hi`

存储体系的目标是实现：`f1 ≫ f2 ≫ ··· ≫ fn`，说明：访问内存比访问外存要多

`存储体系的性能`是由层次结构的`有效存取时间Teff`决定的，它依赖于相继层次的命中率和访问频率。
{% asset_img Teff.png%}
每当发生失效时，就要付出代价去访问较高层次的存储器

这种失效在cache中称为`块失效`，在主存储器中称为`缺页错`（page fault），因为块和页面是这些层次之间传送信息的单位。

`缺页错付出的时间代价要比块缺失付出的更大。`

**存储体系设计的目标：**使Teff接近于M1的t1，总成本接近于Mn的成本。

### cache基本原理
#### cache的功能
根据程序访问的局部性原理，可以在主存和CPU之间设置一个`高速`的容量`相对较小`的存储器，如果当前正在执行的程序和数据存放在这个存储器中，在程序运行时，不必从主存储器取指令和取数据，只需访问这个高速存储器，以提高程序运行速度。这个存储器称作高速缓冲存储器`cache`

`cache由高速的SRAM组成`，它的工作速度数倍于主存，全部功能由`硬件`实现，并且对程序员是`透明`的
{% asset_img cache功能.png%}

cache概念：
1. CPU与主存储器之间的一种高速缓冲装置；
2. cache -主存层次结构：由硬件变换地址和控制调度

cache特点：
1. 位于CPU与主存之间，是存储器层次结构中级别最高的一级；
2. 容量比主存小，目前一般有数KB到数MB；
3. 速度一般比主存快5-10倍，通常由存储速度高的双极型三极管或SRAM组成；
4. 其内容是主存的部分副本；
5. 其用途可用来存放指令，也可用来存放数据；
6. 快存的功能全部由硬件实现，并对程序员透明

#### cache的基本原理
`cache的设计依据`：CPU这次访问过的数据，下次有很大的可能也是访问附近的数据。
``` 
CPU与cache之间的数据传送是以字为单位
主存与cache之间的数据传送是以块为单位。
CPU读主存时，把地址同时送给cache和主存
cache控制逻辑依据地址判断此字是否在cache中，若在，此字立即传送给CPU 。
否则，则用主存读周期把此字从主存读出送到CPU，同时，把含有这个字的整个数据块从主存读出送到cache中
```
{% asset_img cache设计依据.png%}
1. 图中cache分为4行，每行4个字
2. 分配给cache的地址存放在一个`相联存储器CAM`中，它是`按内容寻址`的存储器。
3. 当CPU执行访存指令时，把待访问的字的地址送到CAM中，立刻就可以知道该字命中与否
4. 如果该字不在cache中，则将该字从主存传送到CPU。同时，把该字所在的整个数据块送入cache
5. cache未命中时使用LRU替换策略，即替换最近最少使用的一行数据。 

#### cache的命中率
任何时候都有一些主存块处在cache中。

当CPU发出读请求时，将主存地址s位（或s位中的一部分）与cache某块的标记相比较，根据其比较结果是否相等而区分出两种情况：
1. 当比较结果相等时，说明需要的数据已在cache中，直接访问cache就行了，在CPU与cache之间，通常一次传送一个字；`cache命中`
2. 当比较结果不相等时，说明需要的数据尚未调入cache，那么就要把该数据所在的整个字块从主存一次调进来；`cache不命中`

`命中率`指CPU所要访问的信息在cache中的比率；而将所要访问的信息不在cache中的比率称为`失效率`或`未命中率`。 

`增加cache的目的`，就是在`性能上使主存的平均读出时间尽可能接近cache的读出时间`。因此，`cache的命中率应接近于1`。由于程序访问的局部性原理，这是可能的

在一个程序执行期间：
设Nc表示cache完成存取的总次数，Nm表示主存完成存取的总次数，h定义为命中率，则有：`h = "Nc" /"Nc+Nm" `

若 tc表示命中时的cache访问时间，tm表示未命中时的主存访问时间，1-h表示未命中率，则cache/主存系统的平均访问时间ta为：`ta=htc+(1-h)tm`

**目标**：以较小的硬件代价使`cache/主存系统`的平均访问时间ta越接近tc越好

设`r=tm/tc`表示`主存慢于cache的倍率`，e表示访问效率
`e = "tc" /"ta"  = "tc" /"htc+(1−h)tm" = 1/"h+(1−h)r"="1" /"r+(1−r)h" `

为提高访问效率：`命中率h越接近1越好，r值以5-10为宜，不宜太大`

cache的`容量`和`块长`是影响cache的效率的重要因素
1. cache容量是总成本价与命中率的折中值
2. 通常：每块取4至8个可编址单位（字或字节）较好；也可取一个主存周期所能调出主存的信息长度。

### cache结构设计必须解决的问题
基本结构由`cache存储体`、`地址映射变换机构`、`cache替换机构`几大模块组成
{% asset_img cache存储器.png%}

#### 地址映射（映象）与地址变换
`地址映射`：把主存块按照某种规则（函数或方法）装入或定位到cache中的过程。
`地址变换`：信息按这种映射关系装入cache后，执行程序时，将主存地址变换成 cache地址的变换过程叫做`地址变换`。
`地址映射`和`地址变换`密切相关。 　

基本的地址映射方式：`全相联映射`；`直接映射`；`组相联映射`
`主存空间划分成大小相等的主存块（Block`），cache中存放一个主存块的对应单位称为`槽（Slot）`或`行（line）`，有的书中也称之为`块（Block）`

1. 全相联映射
主存中的任何一个块均可以映射装入到Cache中任何一个块的位置上，比较灵活，Cache的块冲突概率最低、空间利用率最高，但是地址变换速度慢，成本高，实现困难。
2. 直接映射
主存中的每一个块只能被放置到Cache中唯一的一个指定位置，若这个位置已有内容，则产生块冲突，原来的块被无条件替换出去。
直接映射是最简单的地址映射方式，成本低，易实现，地址变换速度块，但该方法不够灵活，Cache的块冲突概率最高、空间利用率最低。
cache的第i块和主存的第j块有如下函数关系
```
i = j mod m ( m为cache的总块数）
i = 0,1,2,…,m-1          
j = 0,1,2,…,n-1
```
3. 组相联映射
是全相联映射和直接映射的折中方案，其优点和缺点介于全相联和直接映射方式之间。
主存中的各块与cache的组号有固定的映射关系，但可以自由映射到对应的cache组中的任一块
```
把cache字块分为u组，每组v块，则cache的总块数为：m=u*v
若j为主存块号，i为cache块号，q为组号，q=0,1,2,…,u-1
按u为模将其映射到cache，那么，主存字块可以用下列映射函数映射到cache的第u组内：q = j  mod  u
凡是符合以上求模公式的主存j块，均会映射到cache的u组内
主存块存放到哪个组是固定的，至于存到该组的那一行是灵活的
v值越大越灵活，而v值越小相联搜索的规模越小，v通常取2、4、8、16，称为v路组相联cache
```
cache和主存机械等分为`相同大小的块`，每一块是由若干个字（或字节）组成。 

#### 替换策略
当一个新的主存块要调入到cache，而允许存放此块的行位置都被其它主存块占满时，就要产生替换，因为`cache工作原理要求它尽量保存最新的数据`

`替换问题与cache的组织方式紧密相关：`
1. 对于采用直接映射的cache来说，因一个主存块只有一个特定的行位置可存放，所以问题解决很简单，把此特定行位置上的原主存块妥善处理后，换出cache即可。
2. 对于全相联映射的cache来说，它的全部行都是可被替换的特定行。
3. 而组相联映射的cache中同组各路的行都是可被替换的特定行，这样就要从允许存放新主存块的若干特定行中选取一行换出。

**LFU（最不经常使用 ）算法**
`将一段时间内被访问次数最少的那行数据换出`
每行设置一个计数器，新行建立后从0开始计数
每访问一次，被访问的行计数器增加1
当需要替换时，对这些特定行的计数值进行比较，将计数值最小的行换出，同时将这些行的计数器清零
`缺点`：不能反映近期cache的访问情况

**LRU（近期最少使用）算法**
`将近期内长久未被访问过的行换出`
每行设置一个计数器，cache每命中一次，命中行计数器清零，其它各行计数器增1。该计数器是未访问次数计数器。当需要替换时，比较各特定行的计数值，`将计数值最大的行换出`

这种算法`保护了刚拷贝到cache中的新数据行`，符合cache工作原理，因而使cache有较高的命中率。

**随机替换**
从特定的行位置中随机地选取一行换出即可。
硬件实现最容易，而且速度也比前两种策略快

`缺点`：随意换出的数据很可能马上又要用，从而增加了映射次数，降低了命中率和cache 的工作效率
这个缺点可以用增大cache的容量来克服。

#### 写操作策略
**写回法（Write Back）**
当CPU对cache写命中时，只修改cache的内容，不立即写入主存，`只当此行被换出时才写回主存`
对一个cache行的多次写命中都在cache中快速完成修改，只是需被替换时才写回速度较慢的主存，减少了访问主存的次数从而提高了效率。

方法：`每个cache行必须配置一个修改位（通常称为“脏”位）`，以反映此行是否被CPU修改过。
当某行被换出时，根据此行修改位为1还是为0，决定是将该行内容写回主存还是简单弃去
对于`cache写未命中`，为包含欲写字的主存块在cache分配一行，将此块整个拷贝到cache后在cache中对其进行修改；拷贝主存块时虽已访问到主存，但此时并不对主存块修改，统一地将主存写修改操作留待换出时进行

`优点`：写cache与写主存分开进行，可显著减少写主存次数。
`缺点`：存在cache/主存不一致性的隐患

**全写法（写直通法Write Through）**
`当cache写命中时`：cache与主存同时发生写修改。这种策略显然较好地维护了cache与主存的内容一致性
`当cache写未命中时`：直接向主存写，但此时是否将修改过的主存块取到cache，有两种选择：
1. 一种是取主存块到cache并为它分配一个行位置；
2. 另一种是不取主存块到cache。

`优点`：cache每行无需设置一个修改位以及相应的判测逻辑。
`缺点`：cache对CPU向主存的写操作无高速缓存功能，降低了cache的功效

**写一次法**
一种基于写回法又结合了全写法的写策略，即写命中和写未命中的处理与写回法基本相同，只是`第一次写命中时要同时写入主存`
在第一次片内cache写命中时， CPU在总线上启动一个存储器写周期。其他cache监听到此主存块地址及写信号后，即可把它们各自保存可能有的该块拷贝及时作废（无效处理），`便于维护系统全部cache的一致性`

### Pentium 4的cache组织
#### Pentium PC采用两级cache结构
{% asset_img Pentium PC采用两级cache结构.png%}
`L1cache` —— 集成在CPU内，其容量是16KB，采用的也是两路组相联映射方式，每行是32字节
CPU中的L1cache分为各8KB的指令cache和数据cache
1. 指令cache是只读的，单端口256位（32字节）向指令预取缓冲器提供指令代码。
2. 数据cache是读写的，双端口，每端口32位（4字节），向两条流水线的整数运算单元和寄存器提供数据或接收数据，两个端口还可组合成一个64位端口与浮点运算单元相接
3. 两个cache与64位数据、32位地址的CPU内部总线相连
`L2cache` —— 安装在主板上，其容量是256 KB或512KB，采用的两路组相联映射方式，每行可以是32，64或128字节。
L2的内容是4～32MB容量主存的子集，L1又是L2的子集，从而使L1未命中处理时间大为缩短，为L1的高速使用提供了支持

#### Pentium4的三级cache组织
1. 取指/译码单元：顺序从L2 cache中取程序指令，将它们译成一系列的微指令，并存入L1指令cache中。
2. 乱序执行逻辑：依据数据相关性和资源可用性，调度微指令的执行，因此微指令可按不同于所取机器指令流的顺序被调度执行
3. 执行单元：执行微指令，从L1数据cache中取所需数据，并在寄存器组中暂存运算结果。
4. 存储器子系统：这部分包括L2 cache、L3 cache和系统总线。当L1、L2cache未命中时，使用系统总线访问主存。系统总线还用于访问I/O资源。
{% asset_img Pentium4的三级cache组织.png%}
Pentium 4的指令cache位于指令译码逻辑和执行部件之间。
`设计理念`：Pentium 4将机器指令译成由微指令组成的简单RISC类指令，而使用简单定长的微指令可允许采用超标量流水线和调度技术，从而增强机器的性能。

#### Intel Core i7处理器的cache结构
{% asset_img Intel Core i7处理器的cache结构.png%}
每个核内有各自私有的L1cache和L2cache
其中，L1数据cache和指令cache都是32KB数据区，皆为8路组相联，存取时间都是4个时钟周期。
L2cache是联合cache，共有256KB数据区，8路组相联，存取时间是11个时钟周期。
该多核处理器还有一个供所有核共享的L3cache，其数据区大小为8MB，16路组相联，存取时间是30~40个时钟周期。
Intel Core i7中所有cache的块大小都是64B。

## 虚拟存储器
一个用户的程序不再分配连续的内存空间，而是把`物理存储器分成多个比较小的存储块，每块的大小相等且长度固定不变`，称为`页面`或`页框`。
`每个进程所需的存储空间被划分成小的固定长度的程序块`，称为`页`。
`页`的长度和`页面`相等

分页技术引申出一种非常重要的存储管理策略——`虚拟存储器`（简称虚存）。
在`存储管理部件（MMU）`的支持下，虚拟存储器技术可以彻底解决存储器的调度与管理问题。

### 虚拟存储器的基本概念
#### 基本概念
`虚拟存储器`是`建立在主存-辅存（外存）物理结构基础上的`，由负责信息划分及主存-辅存之间信息调度的`辅助硬件`及`操作系统的存储管理软件`所组成的一种`存储体系`

将`主存和辅存的地址空间统一编址`，形成一个庞大的存储空间。在这个大空间里，用户自由编程，`完全不必考虑程序在主存中是否装得下，或者放在辅存中的程序将来在主存中的位置`

编好的程序由计算机操作系统装入辅助存储器，程序运行时附加的辅助硬件机构和存储管理软件会把辅存的程序一块块自动调入内存由CPU执行或调出内存
用户感觉到的不再是处处受到主存容量限制的存储系统，而是好像具有一个容量充分大的存储器，这样的存储体系称为`“虚拟存储器”`

虚拟存储器只是一个容量非常大的存储器的逻辑模型，不是任何实际的物理存储器。它借助于磁盘等辅助存储器来扩大主存容量，使之为更大或更多的程序所使用。

虚拟存储器指的是主存-辅存层次。以透明的方式给用户提供了一个比实际主存空间大得多的`程序地址空间`

它能使计算机具有辅存的容量，而接近于主存的速度

#### 实地址和虚地址
虚拟存储器的辅存部分也能让用户象内存一样使用，用户编程时的指令地址允许涉及辅存大小的空间范围，这种指令地址称为`“虚拟地址”`（虚地址）或`“逻辑地址”`。对应的存储空间称为`“虚存空间”`或`“逻辑地址空间”`

实际的主存储器地址则称为`“物理地址”`（ 实地址）。它由CPU引脚送出，是用于访问主存的地址。对应的存储空间称为`“物理存储空间”`或`“主存空间”`

程序进行虚地址到实地址转换的过程成为程序的`再定位`

#### 虚存的访问过程
虚拟存储器的用户程序以虚拟地址编址并存放在辅存中
程序运行时，由`地址变换机构`依据当时分配给该程序的`实地址空间`把程序的一部分调入实存。
每次访存时，首先判断该虚地址所对应的部分是否在实存中：如果是，则进行地址转换并用实地址访问主存；否则，按照某种算法将辅存中的部分程序调度进内存，再按同样的方法访问主存。

`虚拟存储器对设计存储管理软件的系统程序员是不透明的，但对应用程序员而言是透明的`

#### cache与虚存的异同   
`主存-辅存的访问机制`与`cache-主存的访问机制`是`类似`的

`cache-主存之间`以及`主存-辅存之间`分别有`辅助硬件`和`辅助软硬件`负责`地址变换与管理`，以便各级存储器能够组成`有机的三级存储体系`。
`cache-主存`构成了系统的`内存`，而`主存-辅存`依靠辅助软硬件的支持构成了`虚拟存储器`
**相同点**
1. `出发点相同`：两者都是为了`提高存储系统的性价比`而构造的`分层存储体系`，都力图使存储系统的性能接近高速存储器，而价格和容量接近低速存储器。
2. `原理相同`：都是利用了程序运行时的`局部性原理`把`最近常用的信息块`从`相对慢速而大容量的存储器`调入`相对高速而小容量的存储器`

**不同点**
1. `侧重点不同`：cache主要解决`主存与CPU的速度差异问题`；虚存主要解决`存储容量问题`
2. `数据通路不同`：CPU与cache和主存之间`均有直接访问通路`，cache不命中时可直接访问主存；而虚存所依赖的辅存与CPU之间`不存在`直接的数据通路，当主存不命中时只能通过调页解决，CPU最终还是要访问主存
3. `透明性不同`：cache的管理完全由硬件完成，对系统程序员和应用程序员均透明；而虚存管理由软件（操作系统）和硬件共同完成，对实现存储管理的系统程序员不透明，而对应用程序员透明
4. `未命中时的损失不同`：由于主存的存取时间是cache的存取时间的5～10倍，而主存的存取速度通常比辅存的存取速度快上千倍，故主存未命中时系统的性能损失要远大于cache未命中时的损失。

#### 虚存机制要解决的关键问题
1. 调度问题：决定哪些程序和数据应被调入主存
2. 地址映射问题：在访问主存时把虚地址变为主存物理地址；在访问辅存时把虚地址变成辅存的物理地址，以便换页;此外还要解决主存分配、存储保护与程序再定位等问题
3. 替换问题：决定哪些程序和数据应被调出主存
4. 更新问题：确保主存与辅存的一致性

### 三种虚拟存储器
虚存通过增设`地址映射表机构`来实现程序在主存中的`定位`

这种定位技术是`把程序分割成若干个较小的段或页`，用相应的映射表机构，来指明`该程序的某段或某页是否已装入主存`：
1. 若已装入主存，则应同时指明其在主存中所处的开始位置
2. 若未装入主存，则应到辅存中去调段或页，并建立起程序空间和实存空间的地址映射关系。这样，程序执行时通过查映射表，将程序（虚）地址变成主存地址再访问主存。

由于采用的存储映射算法不同，形成了采用多种存储器管理方式的虚拟存储器，其中主要有`页式`、`段式`、`段页式`三种

#### 页式虚拟存储器
##### 页式虚存地址映射
虚地址空间被分成等长大小的页，称为`逻辑页`；主存空间也被分成同样大小的页，称为`物理页`
`虚地址`分为两个字段：`高字段为逻辑页号`，`低字段为页内地址`（偏移量）；`实存地址`也分两个字段：`高字段为物理页号`，`低字段为页内地址`。
通过页表可以把虚地址（逻辑地址）转换成物理地址

##### 转换后援缓冲器TLB（快表）    
由于页表通常在主存中，因而即使逻辑页已经在主存中，也至少要访问两次物理存储器才能实现一次访存，这将使虚拟存储器的存取时间加倍。
为了避免对主存访问次数的增多，把页表中最活跃的部分存放在高速存储器中，组成快表。这个专用于页表缓存的高速存储部件称为转换后援缓冲器，又称`快表`（TLB）。保存在主存中的完整页表则称为`慢表`

`TLB由按内容查询的相联存储器实现，存储慢表中部分信息的副本。 `
##### 内页表和外页表
虚页内容若没有调入主存，则计算机启动输入输出系统，把虚地址指示的一页内容从辅存调入主存，再提供CPU访问。      

虚地址和辅存地址不是一回事，程序员按虚存空间编址，虚地址由虚页号和页内地址组成。以磁盘为例，辅存实际地址由磁盘机号、磁头号、柱面号、块号、块内地址组成，因此从辅存调页时还需要虚存地址空间到辅存地址的变换。这个变换也可以采用类似前述页表的方式。此表称为外页表。

CPU访问主存页面失效时，调用`外页表`把程序的虚地址变换成辅存的实际地址，从辅存调出该虚页，而后根据页表指出实页号再把虚页内容调入主存。

调入由地址变换机构实现

##### 虚拟存储器、TLB和cache的协同操作

#### 段式虚拟存储器
页式虚拟存储器的信息传送单位是定长的页，`优点`是页长固定，因而便于构造页表，易于管理，且不存在外碎片。`缺点`是页长与程序的逻辑大小不相关。

`段式虚拟存储器`，是`以程序的逻辑结构所形成的段（`如主程序、子程序、过程、表格等）作为主存分配单位的虚拟存储器。

段是`按照程序的自然分界划分的长度可以动态改变的区域`。通常，程序员把子程序、操作数和常数等不同类型的数据划分到不同的段中，并且每个程序可以有多个相同类型的段。

在段式虚拟存储系统中，虚地址由`段号`和`段内地址`（偏移量）组成。虚地址到主存地址的变换通过段表实现。

段表的每一个表项对应一个段。每个表项至少包含下面三个字段：
1. 有效位：指明该段是否已经调入实存。
2. 段起址：指明在该段已经调入实存的情况下，该段在实存中的首地址。
3. 段长：记录该段的实际长度。设置段长字段的目的是为了保证访问某段的地址空间时，段内地址不会超出该段长度导致地址越界而破坏其他段。

段表本身也是一个段，一般驻留在主存中。 

段式虚拟存储器有许多`优点`：
1. 段的逻辑独立性使其`易于编译、管理、修改和保护，也便于多道程序共享。`
2. `段长可以根据需要动态改变，允许自由调度，以便有效利用主存空间。`

段式虚拟存储器也有一些`缺点`：
1. 因为段的长度不固定，`主存空间分配比较麻烦`。
2. 容易在段间`留下许多外碎片，造成存储空间利用率降低`。
3. 由于段长不一定是2的整数次幂，因而不能简单地像分页方式那样用虚地址和实地址的最低若干二进制位作为段内偏移量，并与段号进行直接拼接，`必须用加法操作通过段起址与段内偏移量的求和运算求得物理地址`。因此，段式存储管理比页式存储管理方式需要更多的硬件支持。 

#### 段页式虚拟存储器
将段式管理和页式管理相结合，就构成了虚存的段页式管理
实存被等分成页。每个程序则先按逻辑结构分段，每段再按照实存的页大小分页。
。。。。。。

### 虚拟存储器的替换算法
当CPU要用到的数据或指令不在主存时，产生`页面失效`），此时要从辅存调进包含这条指令或数据的页面

1. cache的替换全部靠硬件实现，而虚拟存储器的替换有操作系统的支持。
2. 虚存缺页对系统性能的影响比cache未命中要大得多，因为调页需要访问辅存，并且要进行任务切换。
3. 虚存页面替换的选择余地很大，属于一个进程的页面都可替换。

虚拟存储器中的替换策略一般采用`LRU算法`、`LFU算法`、`FIFO算法`，或将两种算法结合起来使用。
...

## Pentium系列机的虚存组织
### 存储器模型
IA-32体系结构微处理机（地址总线的根数为32根）的存储管理硬件支持三种存储器模型：
1. 平坦存储器模型
内存被组织成单一的、连续的地址空间，称为“线性地址空间”。所有的代码、数据和堆栈均包含在该地址空间内，该空间的字节地址范围为0～2^32-1（4GB）。
{% asset_img 平坦存储器模型.png%}
2. 分段存储器模型
每个程序均使用一组独立的地址空间，每个地址空间就是一个段，段的最大长度为2^32B（4GB）。
逻辑地址由段选择器和偏移量组成，处理机将逻辑地址透明地转换为线性地址
{% asset_img 分段存储器模型.png%}
3. 实地址模式存储器模型
这是为保持与早期的8086处理机兼容的存储器模式。
线性地址空间被分为段，段的最大长度为64KB。
线性地址空间的最大长度为2^20B
{% asset_img 实地址模式存储器模型.png%}

### 虚地址模式    
IA-32体系结构微处理机的虚拟存储器可以通过两种方式实现：`分段`和`分页`
存储管理部件包括`分段部件SU`和`分页部件PU`

`分段部件SU`将程序中使用的`虚地址转换成线性地址`。而`分页部件PU`则将`线性地址转换为物理地址`。
在分段部件SU和分页部件PU中，每一部分都可以`独立打开或关闭`，因而有四种组合方式：
1. 不分段不分页模式
程序中使用的逻辑地址与物理地址相同
2. 分段不分页模式
分段不分页的优点：无需访问页目录表和页表，地址转换速度快
3. 分段分页模式
4. 不分段分页模式

### 分页模式下的地址转换
1. 4KB分页功能
分页机制将内存划分成大小相同的存储块，称为`物理页面`；`每个物理页面大小为4K字节`；内存最大4GB的空间可以分为1M（1048576）个页面。
如果不允许分页，那么分段机制确定的32位线性地址即为物理地址。
如果允许分页，分页机制通过`两级页表结构`将线性地址转换成物理地址：第一级是`页目录表`；第二级是`页表`。
2. 4MB分页功能
页面（页框）大小为4MB的分页方式使用单级页表，减少了一次主存访问，地址转换过程加快了。
此方式下，32位线性地址分为高10位的页面（号）和低22位的页内偏移两个字段。
32位地址模式下，全系统只有一张页表，由控制寄存器CR3指向。
此页表有1K个表项，每项4字节（32位）。












# 指令系统
## 指令系统的发展与性能要求
### 指令系统的发展
从计算机组成的层次结构来说，计算机的指令有`微指令`、`机器指令`和`宏指令`之分：
1. 微指令是微程序级的命令，属于硬件；
2. 宏指令是由若干条机器指令组成的软件指令，属于软件；
3. `机器指令介于微指令与宏指令之间，通常简称为指令`，每一条指令可完成一个独立的算术运算或逻辑运算操作

一台计算机中所有`机器指令的集合`称为该机的`指令系统`或`指令集`。它是程序工作者编制程序的基本依据，也是进行计算机逻辑设计的基本依据 。

`指令系统`是表征计算机性能的重要因素，它的格式与功能不仅直接影响到机器的硬件结构，而且也直接影响到系统软件，影响到机器的适用范围。

`复杂指令系统计算机`，简称`CISC`
`精简指令系统计算机`，简称`RISC`

### 指令系统的性能要求
一个`完善的指令系统`应满足以下四方面的要求：
1. 完备性
用汇编语言编写各种程序时，`指令系统直接提供的指令足够使用`，而不必用软件来实现。要求指令系统丰富、功能齐全、使用方便。
`一台计算机中最基本、必不可少的指令是不多的`。许多指令可用最基本的指令编程来实现。例如，乘除运算指令、浮点运算指令可直接用硬件来实现，也可用基本指令编写的程序来实现。采用硬件指令的目的是提高程序执行速度，便于用户编写程序
2. 有效性
利用该指令系统所编写的程序能够高效率地运行。高效率主要表现在`程序占据存储空间小、执行速度快`
一般来说，一个功能更强、更完善的指令系统，必定有更好的有效性
3. 规整性
包括指令系统的`对称性`、`匀齐性`、`指令格式`和`数据格式`的一致性。
`对称性`：在指令系统中所有的寄存器和存储器单元都可同等对待，所有的指令都可使用各种寻址方式；
`匀齐性`：一种操作性质的指令可以支持各种数据类型，如算术运算指令可支持字节、字、双字整数的运算，十进制数运算和单、双精度浮点数运算等；
`指令格式和数据格式的一致性`：指令长度和数据长度有一定的关系，以方便处理和存取。例如`指令长度和数据长度通常是字节长度的整数倍`。
4. 兼容性
系列机各机种之间具有相同的基本结构和共同的基本指令集，因而指令系统是兼容的，即各机种上基本软件可以通用。
但由于不同机种推出的时间不同，在结构和性能上有差异，做到所有软件都完全兼容是不可能的，只能做到`“向上兼容”`，即`低档机上运行的软件可以在高档机上运行`。

### 低级语言与硬件结构的关系
计算机能够直接识别和执行的唯一语言是`二进制机器语言`，因此，必须借助`汇编程序或编译程序`，把`符号语言或高级语言`翻译成`二进制码组成的机器语言`。

汇编语言依赖于计算机的硬件结构和指令系统。不同的机器有不同的指令，所以`用汇编语言编写的程序不能在其他类型的机器上运行`。


## 指令格式
`影响计算机指令格式的因素`：机器的字长、存储器的容量、指令的功能等
一条指令应包含如下信息：
1. 进行何种操作：即操作性质，体现在指令中被称为`操作码`。
2. 操作的对象：数据来源以及如何寻找操作数。
3. 操作结果：结果存放在何处。
4. 下一条指令又如何寻找。

后三项信息体现在指令中被统称为`地址码`，因此指令由操作码和地址码两部分组成，它的基本格式如下：
{% asset_img 指令格式.png%}


### 操作码
操作码是说明指令操作性质的二进制代码，如进行加法、减法、乘法、除法、取数、存数等
不同的指令用操作码字段的不同编码表示，CPU中有专门的电路来解释每个操作码

操作码所占的二进制位数决定了一台计算机所能允许的指令条数。
例如：操作码占用六位二进制码时，这台计算机最多允许有： 
2^6 ＝ 64 条指令

**操作码字段分两种：**
1. 固定长度操作码
操作码所占的二进制位数固定不变，集中放置在指令字的一个字段中。
这种格式有利于`简化硬件设计`，`减少指令译码时间`，广泛用于字长较长的大、中型计算机和超级小型计算机中。
2. 可变长度操作码
操作码扩展技术的应用，即操作码的长度是可变的，且分散地放在指令的不同字段中。
这种格式`有利于压缩程序中操作码的平均长度`，在字长较短的微型机中被广泛应用。
下面是一种扩展操作码的安排示意：
{% asset_img 扩展操作码.png%}
这是一个16位字长的指令码，包括4位基本操作码字段和三个4位长的地址字段。4位基本操作码，若全部用于三地址指令，则有16条。
显然，4位基本操作码是不够的，必须向地址码字段扩展操作作码的长度。其扩展方法及步骤如下：
1). 15条三地址指令的操作码由4位基本操作码`0000~1110`所给定，剩下一个1111则用于把操作码扩展到A1地址码字段，即由4位扩展到8位； 
{% asset_img 15条三地址指令.png%}
2). 14条二地址指令的操作码由8位操作码的`1111,0000～1111`,1101给定，剩下的1111,1110和1111,1111又可用于把操作码扩充到A2地址字段，即从8位又扩充到12位；        
{% asset_img 14条二地址指令.png%}
3). 31条一地址指令的操作码由12位操作码的`1111,1110,0000 ~ 1111,1111,1110`给定。
{% asset_img 31条一地址指令.png%}
4). 由此类堆，还可以把剩下的`1111,1111,1111`扩充到A3地址码字段而形成16位操作码，这时还可由`1111,1111,1111,0000~1111,1111,1111,1111`给出16条零地址指令
{% asset_img 16条零地址指令.png%}
采用这种方法，指令系统中共有15+14+31+16=76条指令

上述方法是在不增加指令长度的情况下，采用对地址少的指令使用较长的操作码，对地址数多的指令使用较短的操作码。其实质是增加了指令的数量，丰富了指令的功能

在可变长操作码的指令系统设计中，究竟使用何种扩展方法为好？
指令的`使用频度`（即在程序中出现的概率）是非常重要的依据。即`频度高的指令应分配短的操作码，频度低的指令则分配较长的操作码`。这样，既可有效地缩短操作码在程序中的平均长度，节省存储空间，又可缩短常用指令的译码时间以提高程序的运行速度。
其`缺点`是译码系统比固定操作码复杂，增加了设计控制器的难度，需要更多的硬件作支持


### 地址码
指令中的地址码用来指出该指令的`源操作数地址`（一个或两个）、`结果地址`及`下一条指令的地址`
这里的地址可以是`主存地址`，也可以是`寄存器地址`，甚至可以是`I/O设备的地址`
#### 四地址指令
{% asset_img 四地址指令.png%}
`OP`：操作码；`A1`：第一地址码，存放第一操作数；`A2`：第二地址码，存放第二操作数；`A3`：第三地址码，存放操作结果；`A`4：第四地址码，存放下条要执行指令的地址
操作：`（A1）OP（A2）→ A3`
这种指令`直观易懂`，后续指令的地址可任意填写
可直接寻址的地址范围与地址字段的`位数有关`

#### 三地址指令
{% asset_img 三地址指令.png%}
由于采用了`程序计数器`（简称PC），省去了A4地址；
用三地址指令编写的程序，其指令在内存中`必须依次存放`，才能利用`程序计数器自动增量`的办法顺序执行。若程序要转向时，必须用`转移指令改变程序的执行顺序`

#### 二地址指令
{% asset_img 二地址指令.png%}
`OP`：操作码；`A1`：既做第一操作数地址，又做目的地址；`A2`：第二操作数地址。
操作：`（A1） OP（A2） → A1`
在不改变字长和操作码位数的前提下，二地址指令可直接访问的主存地址数为：`2^12=4K`
使用二地址指令编写的程序，其指令在内存中也要`依次存放`，才能用程序计数器自动增量使之顺序执行。若程序发生转向时，也必须用转移指令改变程序的执行顺序。
当二地址指令执行之后，`A1中的内容被修改`了

#### 一地址指令
{% asset_img 一地址指令.png%}
指令中只给出一个操作数地址，另一个操作数地址和目的地址则是`隐含`的。这个隐含的地址就是`运算器的累加寄存器AC`
操作：`（AC）OP（A）→ AC`
在不改变字长和操作码位数的前提下，二地址指令可直接访问的主存地址数为：   `2^24 = 16M`
完成一条指令只需`两次访存`
采用一地址指令编写的程序，其指令在内存中也要顺序存放，由程序计数器自动增量控制其顺序执行。程序转向时，也用转移指令改变程序的执行方向。

在程序执行前，必须用一条“取数指令”把其中一个操作数放到累加寄存器中。程序结束后，累加寄存器的内容已被修改。若要将累加寄存器中的结果送回内存，则必须使用“存数指令”

#### 零地址指令
只有操作码，没有地址码的指令称为零地址指令。如停机指令。

---

在二地址指令格式中，从`操作数的物理位置`来分，指令可以分为三种类型： 
1. `存储器-存储器（SS）型指令`
指令操作中涉及的操作数都在内存单元中，操作结果也保存在内存中。执行这类指令需要多次访存。
2. `寄存器-寄存器（RR）型指令`
指令操作中涉及的操作数都在寄存器中，操作结果也保存在寄存器中。执行这类指令不需要访问存储器，速度很快。
3. `寄存器-存储器（RS）型指令`
执行这类指令时，既要访问内存单元，又要访问寄存器。


### 指令字长度
#### 机器字长
机器字的长度简称`字`长，指计算机能`直接处理的二进制数据的位数`。
字长是计算机中的一项重要技术指标，字长越长，计算机的运算精度越高；
字长还能反映指令的寻址能力，若字长n位全用来寻址，可直接寻址2^n个字节。
一般把机器字长定为字节长度（8位）的整数倍

#### 指令字长
指令字的长度指一个指令字中包含的二进制代码的位数，取决于`操作码的长度`、`操作数地址的长度`和`操作数地址的个数`
指令字的长度也定为字节长度的整数倍

#### 指令字长与机器字长的关系 
指令字长度与机器字长度`没有固定的关系`，它可以等于机器字长，也可以大于或小于机器字长
1. 指令字长度等于机器字长度的指令，称为`单字长指令`
2. 指令字长等于两个机器字长的指令，称为`双字长指令`
3. 指令字长度只有半个机器字长度的指令，称为`半字长指令`
---
1. 等字长指令结构
在同一个指令系统中，所有的指令字长度都是相等的，称为等字长指令字结构， 这种指令字结构简单，控制方便
2. 变字长指令结构
如果`各种指令字长度随指令的功能而变化`，如有的指令是单字长指令，有的指令是双字长指令或三字长指令，则称为变字长指令结构，这种指令字结构灵活，能`充分利用指令字长度，但指令的控制较复杂`


### 指令助记符
由于硬件只能识别1和0，所以采用二进制操作码是必要的，但是用二进制来书写程序却非常麻烦。
为了便于书写和阅读程序，每条指令通常用3个或4个英文缩写字母来表示。这种缩写码叫做`指令助记符`：

## 操作数类型
机器指令对数据进行操作，数据通常分以下四类：
1. `地址数据`：
多数情况下，对指令中操作数的引用必须完成某种计算，才能确定它们在主存中的有效地址，此时，地址被看成无符号整数。
2. `数值数据`：
定点整数或定点小数、浮点数、压缩BCD码。 
3. `字符数据`：
也称文本数据或字符串，目前广泛使用ASCII码。 
4. `逻辑数据`：
一个单元中有几位二进制位项组成，每位的值可以是1或0。当数据以这种方式看待时，称为逻辑性数据

## 指令和数据的寻址方式
存储器既可以存放数据又可以存放指令。因此当某个操作数或某条指令存放在某个存储单元时，其存储单元的编号，就是该操作数或指令在存储器中的地址。

当采用地址指定方式时，形成操作数或指令地址的方式，称为`寻址方式`
寻址方式分为两类，即`指令寻址方式`和`数据寻址方式`，前者比较简单，后者比较复杂
### 指令的寻址方式
指令的寻址方式有两种，一种是`顺序寻址方式`，另一种是`跳跃（转移）寻址方式`
#### 顺序寻址方式
指令地址在内存中按顺序安排，当执行一段程序时，通常是一条指令接一条指令的顺序执行
从存储器取出第一条指令，然后执行这条指令；接着从存储器取出第二条指令，再执行第二条指令；接着再取出第三条指令……这种程序顺序执行的过程，我们称为`指令的顺序寻址方式`
必须使用`程序计数器（又称指令指针寄存器）PC`来计数指令的顺序号，该顺序号就是指令在内存中的地址


#### 转移寻址方式   
当程序转移执行的顺序时，指令的寻址就采取转移寻址方式
所谓转移，是指`下条指令的地址码不是由程序计数器给出，而是由本条指令给出`
程序转移后，按新的指令地址开始顺序执行。`指令计数器的内容也必须相应改变`，以便及时跟踪新的指令地址。

采用`指令转移寻址方式`，可以`实现程序转移或构成循环程序`，从而能缩短程序长度，或将某些程序作为公共程序引用。`指令系统中的各种条件转移或无条件转移指令`，就是为了实现指令的转移寻址而设置的
{% asset_img 指令的寻址方式.png%}

### 操作数基本寻址方式
操作数的寻址就是寻找操作数的地址，其目的是`寻找所需要的操作数`
`寻址方式`就是`形成操作数的有效地址的方法`
**一种单地址指令的结构**
{% asset_img 一种单地址指令的结构.png%}
指令中`操作数字段的地址码`是由`形式地址A`和`寻址方式特征位`等组合形成；
一般来说，指令中所给出的地址码，并不是操作数的`有效地址`
`形式地址A`，也称`偏移量`，是`指令字结构中给定的地址量`
`寻址方式特征位`由`间址位`和`变址位`组成:
1. 如果这条指令无间址和变址的要求，则形式地址就是操作数的有效地址
2. 如果指令中指明要间址或变址变换，则形式地址要经过指定方式的变换，才能形成有效地址

寻址过程就是把操作数的形式地址，变换为操作数的有效地址的过程

#### 隐含寻址     
在指令中不明显地给出操作数的地址，其操作数或操作数的地址隐含在某个通用寄存器中或指定的存储单元中

例如：单地址的指令格式，没有在地址字段中指明第二操作数地址，而是规定累加寄存器AC作为第二操作数地址，AC对单地址指令格式来说是隐含地址。
{% asset_img 隐含寻址.png%}

这种方式可以缩短指令的长度，在字长较短的微型机或小型机中被广泛采用

#### 立即寻址
所需的操作数由指令直接给出，称为立即数寻址方式，简称`立即寻址`

特点：
1. 取指令时将操作码和一个操作数同时取出，不必再次访问存储器，提高了指令的执行速度。
2. 操作数是指令的一部分，不能被修改。
3. 对于定长指令格式，操作数的大小将受到指令长度的限制，所以这种寻址方式灵活性最差。
4. 通常用于给某一寄存器或主存单元赋初值，或者用于提供一个常数。
5. 在微型和小型计算机中，内存是按字节编址的。对立即寻址而言，若前一个字节是操作码，紧跟着的第二个字节就是立即操作数。因此，立即数寻址又称为邻接型寻址，或者说，操作数紧跟着操作码
{% asset_img 立即寻址.png%}

#### 直接寻址
在指令格式的地址字段中直接指出操作数在内存的地址A。采用直接寻址时，指令字中的形式地址A就是操作数的有效地址EA
用D表示操作数，则：`D =（A）`
操作数地址是不能修改的，与程序本身所在的位置无关，所以又叫做`绝对寻址方式`

#### 间接寻址
指令地址字段中的形式地址A不是操作数D的真正地址，而是存放操作数地址的主存单元的地址，简称`操作数地址的地址`
操作数的有效地址的计算公式为：`EA =(A)，D =(EA)=((A))`

**特点：**
因为操作数的有效地址在主存储器中，可以被灵活的修改而不必修改指令，从而使`间接寻址要比直接寻址灵活得多`。
但是，间接寻址在指令执行过程中`至少需要两次访问主存储器`才能取出操作数，严重降低了指令执行的速度
{% asset_img 间接寻址.png%}

##### 寄存器寻址
指令中给出的操作数地址不是内存的地址单元号，而是通用寄存器的编号：`EA=R，D =(R)`
{% asset_img 寄存器寻址.png%}
**优点：**
1. 由于寄存器在CPU的内部，指令在执行时从寄存器中取操作数比访问主存要快得多； 
2. 由于寄存器的数量较少，因此寄存器编号所占位数也较少，从而可以有效减少指令的地址码字段的长度

#### 寄存器间接寻址
{% asset_img 寄存器间接寻址.png%}
即将操作数放在主存储器中，而操作数的地址放在某一通用寄存器中，然后在指令的地址码部分给出该通用寄存器的编号，这时有`EA =(R) `
这种寻址方式的指令较短，并且在取指后只需一次访存便可得到操作数，因此指令执行速度较间接寻址方式要快，也是目前在计算机中使用较为广泛的一种寻址方式。 

#### 偏移寻址
{% asset_img 偏移寻址.png%}
直接寻址和寄存器间接寻址方式的结合
有效地址计算公式为`EA = A +(R)`

要求指令中有两个地址字段，一个地址字段中的形式地址A直接被使用；另一个地址字段指的是某个专用寄存器。
此寄存器的内容加上形式地址A就产生有效地址EA。
常用的三种偏移寻址是`相对寻址`、`基址寻址`、`变址寻址`

##### 相对寻址
程序计数器`PC的内容加上指令格式中的形式地址A而形成操作数的有效地址，EA = A +(PC)`

程序计数器的内容就是`即将执行的下一条指令的地址`。“相对”寻址，就是相对于当前的指令地址而言

此时`形式地址A`通常称为偏移量，其值可正可负，相对于当前指令地址进行浮动。
使用相对寻址可以节省指令中的地址位数，也便于程序在内存中成块搬动

##### 基址寻址
当存储容量较大，所需地址码的长度大于字长时，指令中的地址码部分直接给出的地址不可能直接访问存储器的所有单元。因此，把整个存储空间分成若干段，每段的首地址存放在一个基址寄存器中，段内的位移量由指令直接给出。
于是，存储器的实际地址就等于基址寄存器的内容加上段内位移量。这就叫做`基址寄存器寻址方式`，简称`基址寻址`
基址寄存器的位数可以设置得很长，从而可以在较大的存储空间中寻址。

##### 变址寻址
将指令中的基地址码和一个“变址值”相加后形成操作数的有效地址
“变址值”存放在一个专用的变址寄存器Ri中或专用的内存单元中

变址寻址的用途是为重复操作的完成提供一种高效机制。最典型的应用就是`将指令的地址码部分给出的地址A作为基准地址，而将变址寄存器Ri中的内容作为修改量。在遇到需要频繁修改操作数地址时，无须修改指令，只要修改Ri中的变址值就可以了，这对于数组运算、字符串操作等一些进行成批数据处理的指令是很有用的`

---

**基址和变址的应用方向**    
1. `基址寻址面向系统`，主要用于逻辑地址到物理地址的变换，用来解决程序在主存储器中的再定位和扩大寻址空间等问题。在一些大型机中，基址寄存器是由管理程序利用特权指令来使用，用户程序无权修改它，从而确保了系统的安全性。
2. `变址寻址则面向用户`，用于访问字符串、向量和数组等成批数据，没有逻辑地址到物理地址的变换功能

#### 段寻址方式
这个基地址就是CPU中的段寄存器
这种寻址方式的实质依然是基址寻址

#### 堆栈寻址
堆栈采用“先进后出”的工作方式

##### 串联堆栈(硬堆栈)
在一些计算机的CPU中，设置有`8个或16个寄存器作为堆栈`，由于寄存器具有移位功能，压入（进栈）时，可以从顶部压入，依次移到下面的各个寄存器中；弹出（退栈）时，亦先由顶部寄存器取出，下面寄存器中的内容则逐个向上移动。因此，称为`串联堆栈`

这种堆栈一般不要求堆栈指示器，由硬件支持，又称硬堆栈。这种堆栈通常设在CPU中，操作速度快。但它要受到寄存器数目的限制

##### 存储器堆栈(软堆栈)     
常用的堆栈是利用一部分主存区域，称为`存储器堆栈`
`存储器堆栈有如下优点：`
1. 堆栈的长度可视程序的要求任意设置；
2. 堆栈的数目可由程序员任意规定；
3. 可使用对存储器寻址的任何一条指令来对堆栈中的数据进行寻址。

用存储区设置的堆栈，其中的数据不能像硬堆栈那样一个单元向另一个单元移动。因此，采用堆栈顶部相对于数据进行移动的方法，在CPU中设置一个`堆栈指示器`来指示栈顶的移动情况。相应地，又把存储器堆栈称为`软堆栈`
当软堆栈建立后，该部分存储区则不能再作他用。

---


**基本寻址方式比较**
{% asset_img 基本寻址方式比较.png%}

### Pentium的寻址方式
#### Pentium的工作模式
**实地址模式**
在实地址模式下，逻辑地址形式为段寻址方式:
将段名所指定的段寄存器内容（16位）左移4位，低4位补全0，得到20位段基地址，再加上段内偏移，即得20位物理地址

**保护虚拟地址模式**
在保护模式下，32位段基地址加上段内偏移得到32位线性地址。由存储管理部件将其转换成32位的物理地址

无论是实地址模式还是保护模式，段基地址的获取方式已是固定的方式。我们主要讨论`有效地址`的获取方式


#### Pentium指令格式及寻址方式
{% asset_img Pentium指令格式及寻址方式.png%}

## 典型指令
### 指令的分类
#### 数据传送类指令
实现寄存器与寄存器，寄存器与存储单元以及存储单元与存储单元之间的数据传送

数据传送指令主要包括`取数指令`、`存数指令`、`传送指令`、`成组传送指令`、`字节交换指令`、`清寄存器指令`、`堆栈操作指令`等等
#### 算术运算指令
这类指令包括`二进制定点加、减、乘、除指令，浮点加、减、乘、除指令，求反、求补指令，算术移位指令，算术比较指令，十进制加、减运算指令等`。这类指令主要用于`定点或浮点的算术运算`
#### 逻辑运算指令
这类指令包`括逻辑加`、`逻辑乘`、`逻辑比较`、`测等指令`、`按位加`、`逻辑移位`等指令，主要用于`无符号数的位操作、代码的转换、判断及运算`。移位指令用来对寄存器的内容实现左移、右移或循环移位
#### 程序控制指令
`程序控制指令`也称`转移指令`
程序控制指令也称转移指令。执行程序时，有时机器执行到某条指令时，出现了几种不同结果，这时机器必须执行一条转移指令，根据不同结果进行转移，从而改变程序原来执行的顺序。这种转移指令称为条件转移指令。

除各种`条件转移指令外，还有无条件转移指令、转子程序指令、返回主程序指令、中断返回指令`等。 转移指令的转移地址一般采用直接寻址和相对寻址方式来确定。

`转子指令`是转向本指令操作地址所指出的子程序入口，并将原程序中下一条指令地址存入内存某单元（或指定的某个寄存器）中，以便为返回主程序时提供返回地址
#### 输入输出指令 
输入输出指令主要用来启动外围设备，检查测试外围设备的工作状态，并实现`外部设备和CPU之间，或外围设备与外围设备之间`的信息传送
#### 字符串处理指令
字符串处理指令是一种`非数值处理指令`，一般包括字符串传送、字符串转换（把一种编码的字符串转换成另一种编码的字符串）、字符串替换（把某一字符串用另一字符串替换）等。这类指令在文字编辑中对大量字符串进行处理
#### 陷阱（TRAP）指令
陷阱是一种意外事故中断，它的目的`不是请求CPU正常处理中断`，`而是为了把发生的故障通知CPU，并根据故障的情况转入相应的故障处理程序`。陷阱指令就是为实现这个任务而设置的。

一般为`隐含指令`

#### 特权指令
特权指令是指具有特殊权限的指令。这类指令`只用于操作系统或其他系统软件`，一般不直接提供给用户使用。 
在多用户、多任务的计算机系统中特权指令必不可少。它主要用于系统资源的分配和管理

#### 其他指令
状态寄存器置位、复位指令、测试指令、暂停指令，空操作指令，以及其他一些系统控制用的特殊指令。 

### 精简指令系统计算机 

`RISC，精简指令系统计算机`
提供数目较少、格式与功能简单、运行高效的指令
`特点`：追求的是计算机控制器实现简单，运行高速，更容易在单块超大规模集成电路的芯片内制做出来

---
`CISC，复杂指令系统计算机`
`特点`：指令条数多，格式多样，寻址方式复杂，每条指令的功能强。汇编程序设计容易些，但计算机控制器的实现困难多，很多指令被使用的机会并不多。

精简指令系统计算机`不仅是要简化指令系统`，而且要通过简化指令系统使计算机的`硬件结构变得简单合理`，以`提高运算速度`，**最有效的办法是减少指令的执行周期数**

RISC技术的**实质**是要求`指令系统简化`，`尽量使用寄存器-寄存器操作指令，指令操作在一个周期内完成，指令格式力求一致，以利于提高编译的效率`

#### 一些性能指标
若设高级语言程序经编译后在机器上运行的`机器指令数为I`；每条机器指令执行时所需要的`平均机器周期数是C`；每个机器周期的`执行时间为T`；则计算机执行程序的时间`P=I×C×T`

#### RISC的主要特点
RISC继承了CISC的成功技术，又克服了CISC的缺点，其发展速度很快
1. 选取使用频率最高的一些简单指令和很有用但不复杂的指令；
2. 指令长度固定，指令格式种类少，寻址方式种类少；
3. 只有取数/存数指令可以访问存储器，其余指令的操作都在寄存器之间进行
4. 大部分指令在一个机器周期内完成，复杂指令可化为简单指令序列，把它当成子程序使用；
5. CPU中通用寄存器很多；
6. 控制器采用组合逻辑部件，而不采用微程序控制；
7. 取指令和执行指令采用流水线重叠操作，提高了运行速度和信息处理能力；
8. 使存储器靠近CPU，以减少传送数据的时间延迟，并在主存和外存之间设置中间速度存储器，以加速主存和外存之间的信息传送；
9. 以简单有效的方式支持高级语言

#### 指令系统的兼容问题
1. `CISC的兼容性`
当前，计算机公司生产的`各种CISC都能够实现软件兼容`，新型号或高档机包含了旧型号或低档机的全部指令并加以扩充。因此，用户的目标码程序可以不加修改直接在新机器上运行。
2. `RISC的兼容性`
RISC机则将指令做了简化，数量减少，格式也不同，与老机器不能兼容。因为大多数用户的程序是用高级语言编写的，重新在RISC上编译一次即可运行。
有的公司仍然考虑到目标码兼容的问题，例如HP公司开发的目标码翻译器与浮点数转换软件等，可使目标码程序在采用RISC技术的精密体系计算机中运行。    


# 中央处理器
## CPU的功能和组成
### CPU的功能
`指令控制`：即`程序的顺序控制`，程序中指令的相互顺序不能任意颠倒。
`操作控制`：`一条指令有若干操作信号实现`，CPU管理并产生由内存取出的每条指令的操作信号，把各种操作信号送往相应的部件，从而控制这些部件按指令的要求进行动作。
`时间控制`：`对指令的各种操作实施时间的定时`，各种指令的操作信号均受到时间的严格定时，一条指令的整个执行过程也受到时间的严格定时
`数据加工`：`对数据进行算术运算和逻辑运算处理`

### CPU的基本组成
运算器、控制器、cache
{% asset_img CPU的基本组成.png%}
#### 控制器
由`程序计数器`、`指令寄存器`、`指令译码器`、`时序产生器`和`操作控制器`组成，完成协调和指挥整个计算机系统的操作
主要功能：
1. 从指令cache中取出一条指令，并指出下一条指令在指令cache中的位置。
2. 对指令进行译码或测试，并产生相应的操作控制信号，以便启动规定的动作。
3. 指挥并控制CPU、数据cache和输入/输出设备之间数据流动的方向。

#### 运算器
由`算术逻辑单元ALU`、`通用寄存器`、`数据缓冲寄存器DR`和`状态条件寄存器PSW`组成，是数据加工处理部件。

所有操作由控制器发出的控制信号来指挥，是`执行部件`。

运算器的两个功能：
1. 执行所有的算术运算；
2. 执行所有的逻辑运算，并进行逻辑测试，如零值测试或两个值的比较。

通常，一个算术运算产生一个运算结果，而一个逻辑运算则产生一个判决。

### CPU中的主要存储器
CPU中至少包含六类寄存器：
1. 指令寄存器IR
2. 程序计数器PC
3. 数据地址寄存器AR —— 如果不考虑CPU中的cache，需要直接访问存储器，则为存储器地址寄存器MAR
4. 数据缓冲寄存器DR —— 如果不考虑CPU中的cache，需要直接访问存储器，则为存储器数据寄存器MDR
5. 通用寄存器组
6. 状态字寄存器PSW

#### 指令寄存器IR
1. 保存当前正在执行的一条指令。当执行一条指令时，先将它从`指令cache`（指存）读出，传送至IR。
2. IR中指令操作码字段经过`指令译码器`译码，向操作控制器发出具体操作的特定信号。
3. 在执行该指令的过程中，`IR的内容不允许发生变化`，以保证实现指令的全部功能。

#### 程序计数器PC
又称为`指令计数器`
1. 程序开始执行前，将`起始地址（程序的第一条指令所在的地址）送入PC`
2. 执行指令时，CPU自动修改PC的内容，使PC中总是存放`将要执行的下一条指令的地址`（指令顺序执行，PC+1）
3. 执行转移指令时，后继指令地址由转qwqw=移指令来规定，因此`PC具有寄存器和计数两种功能`

#### 数据地址寄存器AR
保存当前CPU所访问的`数据cache`（数存）单元的地址

#### 数据缓冲寄存器DR
1. 暂存`ALU的运算结果`，作为ALU运算结果和通用寄存器之间信息传送中时间上的缓冲
2. 暂存`数据存储器读出的一个数据字或来自外部接口的一个数据字`，补偿CPU和内存、外围设备之间在操作速度上的差别

#### 通用寄存器
1. ALU执行算术或逻辑运算时，为ALU提供一个工作区。
2. 通用寄存器组中的寄存器既可以存放源操作数，又可以存放结果操作数，因此在指令格式中要对寄存器号加以编址。
3. 通用寄存器还可以用作地址指示器、变址寄存器、堆栈指示器等。

#### 状态字寄存器PSW
是一个由`各种状态条件标志拼凑而成`的寄存器。
1. 保存由`算术指令和逻辑指令运算或测试结果建立的各种条件信息`，如运算结果进位标志、运算结果溢出标志等。
2. 保存`中断和系统工作状态`，以便使CPU和系统能及时了解机器运行状态和程序运行状态

### 操作控制器与时序产生器
寄存器之间传送信息的通路，称为`数据通路`

`在各寄存器之间建立数据通路的任务`，是由`操作控制器`来完成的

`操作控制器`的功能：根据指令操作码和时序信号，产生各种操作控制信号，以便正确地选择数据通路，把有关数据打入到一个寄存器，从而完成取指令和执行指令的控制

`操作控制器`可以分成两种：
1. **硬布线控制器**——采用`时序逻辑技术`实现
2. **微程序控制器**——采用`存储逻辑`实现

`操作控制器`产生的控制信号必须定时，因此必须有`时序产生器`。`时序产生器`的`作用`：对各种操作信号实施时间上的控制。
CPU中其他功能部件：中断系统、总线接口等

#### 硬布线控制器的特点
`优点`：速度快，可用于速度要求较高的机器中。
`缺点`：
1. 缺乏规整性
2. 缺乏灵活性

#### 微程序控制器的特点  
其`实质`是`用程序设计的思想方法来组织操作控制逻辑`
把指令执行所需要的所有控制信号存放在`控制存储器`中，需要时从这个存储器中读取，存储逻辑可以修改`控制存储器`中存放的数据，从而修改逻辑功能，速度略慢，有一个寻址和读数据的过程

`优点`：规整性、灵活性、可维护性好
`缺点`：速度慢

## 指令周期
### 指令周期的基本概念    
`指令周期`：取指令、分析指令到执行完该指令所需的全部时间。 
各种指令的操作功能不同，因此`各种指令的指令周期`不尽相同。
`指令周期`可以划分为若干个`机器周期`，每个机器周期完成一个基本操作，又称`CPU周期`，`由一个或多个时钟周期构成` 
`时钟周期`：一般指`CPU时钟周期`，通常定义为计算机主频的倒数，是计算机中最基本的时间单位。

通常`用主存中读取一个指令字的最短时间`来规定`CPU周期`。不同的指令，可能包含`不同数目`的CPU周期

在一个`CPU周期`中，包含若干个相等的时间段，即`T周期`（称为`节拍脉冲`，是`处理操作的最基本时间单位`）
节拍常用具有一定宽度的电位信号表示，称之为`节拍电位`
节拍的宽度`取决于`CPU完成一次基本的微操作的时间

每个机器周期（CPU周期）包含的节拍数可以相等，也可以不等，分别称为`定长机器周期`（CPU周期）和`不定长机器周期`（CPU周期）

`取指周期`：
1. 从指存取出指令；
2. PC+1，为取下一条指令做准备；
3. 对指令操作码进行译码或测试，以便确定进行什么操作。

`执行周期`：根据对指令操作码的译码或测试，进行指令所要求的操作

### MOV指令的指令周期
{% asset_img MOV指令的指令周期.png%}
MOV指令是RR型指令，需要两个CPU周期——取指和执行

#### 取指周期
假定程序已经装入指存
1. 程序计数器PC中装入第一条指令地址***
2. PC的内容被放到指存地址总线ABUS(I)上，对指存进行译码，并启动读命令
3. 从********号地址读出的MOV指令通过指令总线IBUS装入指令寄存器IR
4. PC+1，变成***+1，为取下一条指令做好准备
5. IR中的操作码（OP）被译码
6. 操作控制器OC识别出是MOV指令，至此，取指周期结束

在执行周期，操作控制器OC将产生相应操作命令
{% asset_img 指令周期.png%}

#### 执行周期
1. 操作控制器OC送出控制信号到通用寄存器，选择R1（内容为10）作源寄存器，选择R0作目标寄存器；
2. OC送出控制信号到ALU，指定ALU做传送操作；
3. OC送出控制信号，打开ALU输出三态门。将R1寄存器作为ALU输出送到数据总线DBUS上
**注意：任意时刻DBUS上只能有一个数据！**
4. OC送出控制信号，将DBUS上的数据打入数据缓冲寄存器DR（10）；
5. OC送出控制信号，将DR中的数据10打入目标寄存器R0，R0的内容由00变成10

### LAD指令的指令周期
LAD指令是RS型指令，先从指存中取出指令，然后从数存6号单元取出数据100装入通用寄存器R1，原来R1中存放的数据10被更换成100

由于一次访问指存，一次访问数存，因此LAD指令的指令周期需要3个CPU周期

1. 取值周期
CPU的动作完全与MOV指令取指周期相同，只是PC提供的指令地址102，按此地址从指存中读出“LAD  R1，6”指令放入IR中，然后PC+1，使PC内容变为103，为取下一条ADD指令做好准备
2. 执行周期
操作控制器OC发出控制命令打开IR输出三态门。将指令中的直接地址码6放到数据总线DBUS上
OC发出操作命令，将地址码6装入数据地址寄存器AR；
OC发出读命令，将数存6号单元中的数100读出到DBUS上
OC发出命令，将DBUS上的数据100装入数据缓冲寄存器DR；
OC发出命令，将DR中的数100装入通用寄存器R1，覆盖掉R1中原来的数10。至此，LAD指令执行周期结束

**注意：数据总线DBUS上分时进行了地址传送和数据传送，所以需要2个CPU周期**

### ADD指令的指令周期
ADD指令是RR型指令，在运算器中用两个寄存器R1和R2的数据进行加法运算，需要两个CPU周期——取指和执行
1. 取指周期
CPU的动作同MOV、LAD指令。PC提供的指令地址103，按此地址从指存中读出“ADD  R1，R2”指令放入IR中，然后PC+1，使PC内容变为104，为取下一条STO指令做好准备
2. 执行周期
操作控制器OC送出控制命令到通用寄存器，选择R1做源寄存器，R2做目标寄存器；
OC送出控制命令到ALU，指定ALU做R1和R2的加法运算
OC送出控制命令，打开ALU三态门，运算结果120放到DBUS上
OC送出控制命令，将DBUS上的数据打入数据缓冲寄存器DR；将ALU产生的进位信号保存在状态字寄存器PSW中；
OC送出控制命令，将DR（120）装入R2，R2中原来的内容20被冲掉。至此，ADD指令执行周期结束

### STO指令的指令周期
STO指令是RS型指令，先访问指存取出STO指令，然后按（R3）=30地址访问数存，将（R2）=120写入30号单元。

由于一次访问指存，一次访问数存，因此需要3个CPU周期
{% asset_img STO指令的指令周期.png%}
1. 取指周期：同MOV、LAD、ADD
2. 执行周期
操作控制器OC送出控制命令到通用寄存器，选择（R3）=30做数据存储器的访问地址
OC发出操作命令，打开通用寄存器输出三态门（不经ALU以节省时间），将地址30放到DBUS上；
OC发出操作命令，将地址30打入AR，并进行数存地址译码
OC发出操作命令到通用寄存器，选择（R2）=120，作为数存的写入数据；   
OC发出操作命令，打开通用寄存器输出三态门，将数据120放到DBUS上
OC发出操作命令，将数据120写入数存30号单元，30号单元中原先的数据40被覆盖。至此，STO指令执行周期结束


**DBUS是单总线结构，先送地址（30），后送数据（120），必须分时传送。因此，执行周期需要两个CPU周期**

### JMP指令的指令周期
JMP指令是一条无条件转移指令，用来改变程序的执行顺序。指令周期为两个CPU周期。
1. 取指周期
同MOV、LAD、ADD、STO。
2. 执行周期
操作控制器OC送出控制命令，打开指令寄存器IR的输出三态门；将IR中的地址码101发送到DBUS上
OC送出控制命令，将DBUS上的地址码101打入程序计数器PC中，PC中原先的内容106被更换
下一条指令不是从指存106号单元取出，而是转移到101号单元取出。JMP指令执行周期结束

### 用方框图语言表示指令周期
`方框`：一个方框代表一个CPU周期
`方框中的内容`：表示数据通路操作或某种控制操作
`菱形符号`：某种判别或测试，时间上依附于紧接它的前面一个方框的CPU周期，`而不单独占用一个CPU周期`
`～`：表示一条指令已经执行完毕，转入`公操作`【`公操作`，就是一条指令执行完毕后，CPU所开始进行的一些操作，这些操作`主要是CPU对外围设备请求的处理`，如中断处理、通道处理等。
】
如果外围设备没有向CPU请求交换数据，那么CPU转向指存取下一条指令。
{% asset_img 用方框图语言表示指令周期.png%}
`所有指令的取指周期是完全相同的`，指令的执行周期，由于各条指令的功能不同，所用的CPU周期各不相同
DBUS代表数据总线，ABUS（D）代表数存地址总线，ABUS（I）代表指存地址总线，RD（D）代表数存读命令，WE（D）代表数存写命令，RD（I）代表指存读命令。

## 时序产生器和控制方式
### 时序信号的作用和体制
从`时间`上来说，`取指令事件发生在指令周期的第一个CPU周期中，即发生在“取指令”阶段，而取数据事件发生在“执行指令”阶段`

`硬布线控制器`：主状态周期—节拍电位—节拍脉冲三级体制
`微程序控制器`：节拍电位—节拍脉冲二级体制
主状态周期：可以用一个触发器的状态持续时间来表示；
节拍电位：一个CPU周期。

### 时序信号产生器
时序信号发生器由`时钟源`、`环形脉冲发生器`、`节拍脉冲读写时序译码逻辑`、`启停控制逻辑`等组成

#### 时钟源
用来为环形脉冲发生器`提供频率稳定且电平匹配的方波时钟脉冲信号`。通常由石英晶体振荡器和与非门组成的正反馈振荡电路组成，其输出送至环形脉冲发生器。
#### 环形脉冲发生器
`产生一组有序的间隔相等或不等的脉冲序列`，以便通过译码电路来产生最后所需的节拍脉冲
#### 节拍脉冲和存储器读/写时序

#### 启停控制逻辑
机器一旦接通电源，就会自动产生原始的节拍脉冲信号T1° ~ T4°，然而，只有在启动机器运行的情况下，才允许时序发生器发出CPU工作所需的节拍脉冲T1 ~ T4，对读/写时序信号也需要由启停逻辑加以控制。 
启动、停机是随机的，使用触发器可以实现启停逻辑。
`当计算机启动时，一定要从第1个节拍脉冲前沿开始工作，停机时一定要在第4个节拍脉冲结束后关闭时序产生器`

### 控制方式
控制不同操作序列时序信号的方法，称为控制器的**控制方式**，可以分为：`同步控制方式`、`异步控制方式`、`联合控制方式`
其实质反映了时序信号的定时方式

#### 同步控制方式
指令在执行时所需的机器周期数和时钟周期数是固定不变的

根据不同的情况，选取的方案如下：
1. `采用完全统一的机器周期`执行各种不同的指令。因此`所有指令周期具有相同的节拍电位数和节拍脉冲数。`
对于简单指令和简单的操作来说，造成时间浪费
2. `采用不定长机器周期。`
将大部分操作安排在一个较短的机器周期内完成，对某些时间紧张的操作，则采取延长机器周期的办法来解决
3. `中央控制和局部控制结合`。
将大部分指令安排在固定的机器周期完成，称为中央控制；对少数复杂指令（乘、除、浮点运算）采用另外的时序进行定时，称为局部控制

#### 异步控制方式
无统一的时序信号
`特点：`
1. 每条指令、每个操作控制信号需要多少时间就占用多少时间，因此每条指令的指令周期可由多少不等的机器周期数组成；
2. 当控制器发出某一操作控制信号后，等待执行部件完成操作后发回“回答”信号，再开始新的操作。

`优点`：运行速度快
`缺点`：控制电路比较复杂

#### 联合控制方式
将同步控制方式与异步控制方式结合使用
1. 大部分操作序列安排在固定的机器周期中，对某些时间难以确定的操作则以执行部件的“回答”信号作为本次操作的结束。
2. 另一种情况，机器周期的节拍脉冲数固定，但是各条指令所包含的机器周期数不固定。如：`微程序控制器采用联合控制方式`

`优点`：能保证一定的运行速度
`缺点`：电路设计相对复杂  
## 微程序控制器
### 微程序控制原理
#### 微命令和微操作
`微命令`：控制部件通过控制线向执行部件发出的各种控制命令，是`构成控制序列的最小单位`
微命令是控制计算机各部件完成某个基本微操作的命令

`微操作`：执行部件接受微命令后所进行的操作
微命令和微操作是一一对应的
微命令是微操作的控制信号，微操作是微命令的操作过程
微操作是执行部件中最基本的操作

`状态测试`：执行部件通过反馈线向控制部件反映操作情况，以便使控制部件根据执行部件的“状态”来下达新的微命令

由于数据通路的结构关系，微操作可分为`相容性`和`相斥性`两种。
1. `相容性微操作`：能够同时或在同一个CPU周期内并行执行的微操作。
2. `相斥性微操作`：是指不能同时或不能在同一个CPU周期内并行执行的微操作。

#### 微指令和微程序
`微指令`：机器的一个CPU周期中，一组实现一定操作功能的微命令的组合
是微命令的组合，`存储在控制器中的控制存储器中`；

一条`微指令`至少包含两部分信息： 
1. `操作控制字段`，又称`微操作码字段`，用以`产生某一步操作所需的各个微操作控制信号。` 
2. `顺序控制字段`，又称`微地址码字段`，用以`控制产生下一条要执行的微指令地址。`

`微地址` ：存放微指令的控制存储器的单元地址。

`微程序`：一系列微指令的有序集合，一段微程序对应一条机器指令

#### 微程序控制器原理框图
微程序控制器主要由`控制存储器`、`微指令寄存器`和`地址转移逻辑`三大部分组成.其中微指令寄存器分为`微地址寄存器`和`微命令寄存器`
{% asset_img 微程序控制原理.png%}
##### 控制存储器
是微程序控制器的`核心部件`，用来存放实现全部指令系统的微程序，是一种`只读型存储器`。其性能（包括容量、速度、可靠性等）与计算机的性能密切相关。

控制存储器的工作周期就是`微指令周期`，即读出一条微指令并执行微指令的时间总和

控制存储器的字长就是微指令字的长度，其存储容量视机器指令系统而定，即取决于微程序的数量。
`对控制存储器的要求`：速度快，读出周期短。

##### 微指令寄存器
用来存放从控制存储器取出的正在执行的微指令，其位数同微指令字长相等，分为`微地址寄存器`（uMAR）和`微命令寄存器`。
`微地址寄存器`决定将要访问的下一条微指令的地址。
`微命令寄存器`保存一条微指令的操作控制字段和判别测试字段的信息。

##### 地址转移逻辑
为下一步从控制存储器中读取微指令作准备。
`微程序顺序执行时`，下一条微指令的地址直接由微地址寄存器给出。
`微程序出现分支时`，通过判别`测试字段P`和`执行部件的“状态条件”反馈信息`，修改`微地址寄存器`的内容，并按改好的内容去读下一条微指令。

**微程序控制器的工作过程**
1. 执行取指令的公共操作
取指令的公共操作通常由`一段取指微程序来完成`，`在机器开始运行时，自动将取指微程序的入口微地址送`uMAR，并从uCM中读出相应的微指令送入uIR。
微指令的操作控制字段产生相关微命令，来控制实现取机器指令的公共操作。
取指微程序的入口地址一般为CM的0号单元，当取指微程序执行完后，从主存中取出的机器指令就已存入IR中了。
2. 由`机器指令的操作码字段通过微地址形成部件产生出该机器指令所对应的微程序的入口地址`，并送入MAR。
3. 从uCM中逐条取出对应的微指令并执行，每条微指令都能自动产生下一条微指令的地址。 
4. 一条机器指令对应的微程序的最后一条微指令执行完毕后，其下一条微指令地址又回到取指微程序的`入口地址`，从而继续第1）步，以完成取下条机器指令的公共操作。
*以上是一条机器指令的执行过程，如此周而复始，直到整个程序的所有机器指令执行完毕*


#### CPU周期与微指令周期的关系
在串行方式的微程序控制器中，`微指令周期`等于读出微指令的时间加上执行该微指令的时间
为了保证整个机器控制信号的同步，设定一个微指令周期等于CPU周期
{% asset_img CPU周期与微指令周期的关系.png%}
一个CPU周期为0.8us，包含四个等间隔的节拍脉冲T1～T4，则每个脉冲宽度为200ns。用T4作为读取微指令的时间，用T1+T2+T3作为执行微指令的时间

#### 机器指令与微指令的关系
一条机器指令对应一个微程序，一条机器指令所完成的操作划分成若干条微指令来完成，由微指令进行解释和执行。

从指令与微指令，程序与微程序，地址与微地址的一一对应关系来看，前者和主存储器有关，后者与控制存储器有关。

### 微程序设计技术
#### 微命令编码
对微指令中的操作控制字段采用的表示方法
1. 直接表示法
控制字段中的每一位表示一个微命令。
`优点`：简单直观，输出直接用于控制
`缺点`：控制字段长，如三、四百位
控制存储器容量要大
2. 编码表示法
a. 把相斥性微命令编为一组；
b. 对微命令进行编码，留出一个代码表示本段不发出微命令；
c. 增设微命令译码器。
`优点`：可以避免互斥，使指令字大大缩短
`缺点`：增加了译码电路，使微程序的执行速度减慢
**目前在微程序控制器设计中，编码表示法使用较普遍**
`编码原则`：
```
把相斥性的微命令分在同一段内，相容性的微命令分在不同段内。这样不仅有助于提高信息的利用率，缩短微指令字长，而且有助于充分利用硬件所具有的并行性，加快执行的速度。 
应与数据通路结构相适应。
每个小段中包含的信息位不能太多，否则将增加译码线路的复杂性和译码时间。
一般每个小段还要留出一个状态，表示本字段不发出任何微命令。
```
3. 混合表示法

#### 微地址的形成方法
1. 计数器方式
微程序顺序执行时，其后继微地址就是现行微地址加上一个增量（通常为1）；
当微程序遇到转移或转子程序时，由微指令的转移地址段来形成转移微地址。 
在微程序控制器中也有一个微程序计数器uPC，一般情况下都是将微地址寄存器uMAR作为uPC。
`优点`：简单、易于掌握，编制微程序容易。 
`缺点`：这种方式不能实现两路以上的并行微程序转移，因而不利于提高微程序的执行速度，灵活性较差。
2. 多路转移方式
一条微指令具有多个转移分支的能力。当微程序出现分支时，按顺序控制字段的“判别测试”标志和“状态条件”信息来选择后继微地址。
`特点`：能以较短的顺序控制字段配合，实现多路并行转移，灵活性好，速度较快，但转移地址逻辑需要用组合逻辑方法设计

#### 微指令格式
微指令的编译方法是决定微指令格式的主要因素，可以分成两类：`水平型微指令`和`垂直型微指令`
1. 水平型微指令
一次能定义并能并行执行多个微命令的微指令。
`优点`： 
```
微指令字较长，速度越快； 
微指令中的微操作有高度的并行性； 
微指令译码简单；
控制存储器的纵向容量小，灵活性强。 
```
`缺点`： 
```
微指令字比较长，明显地增加了控制存储器的横向容量； 
水平微指令与机器指令差别很大，一般要熟悉机器结构、数据通路、时序系统以及指令执行过程的人才能进行微程序设计，对用户来说很困难
```
2. 垂直型微指令
类似于机器指令的结构，有操作码，一次只能执行1或2个微命令的微指令。
`优点`： 
```
微指令字短，一般为10～20位左右；
微指令的并行微操作能力有限，一般只包含1个微操作命令；
微指令译码比较复杂，全部微命令用一个微操作控制字段进行编码，微指令执行时需完全译码； 
设计用户只需注意微指令的功能，而对微命令及其选择、数据通路的结构则不用过多地考虑，因此，便于用户编制微程序。而且，编制的微程序规整、直观，便于实现设计的自动化；
垂直微指令字较短，使控制存储器的横向容量少。
```
`缺点`：
```
用垂直微指令编制微程序要使用较多的微指令，微程序较长；
要求控制存储器的纵向容量大；
垂直微指令产生微命令要经过译码，微程序执行速度慢； 
不能充分利用数据通路具有多种并行操作能力。
```
3. 水平型微指令和垂直型微指令的`比较`
水平型微指令并行操作能力强，效率高，灵活性强，垂直型微指令则较差。 
水平型微指令执行一条指令的时间短，垂直型微指令执行时间长。 
由水平型微指令解释指令的微程序，有微指令字较长而微程序短的特点。垂直型微指令则相反。 
水平型微指令用户难以掌握，而垂直型微指令与指令比较相似，相对来说，比较容易掌握。

#### 动态微程序设计
`静态微程序设计`：对应于一台计算机的机器指令只有一组微程序，这一组微程序设计好之后，一般无须改变而且也不好改变。 

`动态微程序设计`：采用E2PROM作为控制存储器，可以通过改变微指令和微程序来改变机器的指令系统。
微指令和微程序可以根据需要加以改变，因而可以在一台机器上实现不同类型的指令系统，又称为`仿真其他机器指令系统`，以便扩大机器的功能


## 硬连线（硬布线）控制器
通过逻辑电路直接连线而生成的控制器，又称为`组合逻辑控制器`。
`设计目标`：使用最少元件（复杂的树形网络），速度最高。
`微操作控制信号产生`： 
在微程序控制器中，微操作控制信号由微指令产生，并且可以重复使用。
在硬布线控制器中，某一微操作控制信号由布尔代数表达式描述的输出函数产生。 
`设计微操作控制信号的方法和过程`：根据所有机器指令流程图，寻找出产生同一个微操作信号的所有条件，并与适当的节拍电位和节拍脉冲组合，从而写出其布尔代数表达式并进行简化，然后用门电路或可编程器件来实现

**设计步骤**：
1. 画出指令流程图
2. 列出微操作时间表 
微操作时间表形象地表明：什么时间、根据什么条件发出哪些微操作信号。将指令流程图中的微操作合理地安排到各个机器周期的相应节拍和脉冲中去。
3. 进行微操作信号的综合 
当列出所有指令的微操作时间表之后，需要对它们进行综合分析，把凡是要执行某一微操作的所有条件（哪条指令、哪个机器周期、哪个节拍和脉冲等）都考虑在内，加以分类组合，列出各微操作产生的逻辑表达式，然后加以简化，使逻辑表达式更为合理。 
4. 实现电路 
根据整理并化简的逻辑表达式组，可以用一系列组合逻辑电路加以实现，如逻辑门电路的组合、PLA或其他逻辑电路。
 
## 流水CPU
### 并行处理技术
#### 并行处理技术
1. 时间并行
即时间重叠，在并行性概念中引入时间因素，让多个处理过程在时间上相互错开，轮流重叠地使用同一套硬件设备的各个部分，以`加快硬件周转而赢得速度`。
2. 空间并行
指资源重复，在并行性概念中引入空间因素，`以“数量取胜”`为原则来`大幅度提高计算机的处理速度`。
大规模和超大规模集成电路的迅速发展为空间并行技术带来了巨大生机，因而成为目前实行并行处理的一个主要途径，主要体现在多处理器系统和多计算机系统。
3. 时间并行+空间并行
时间重叠与资源重复的综合应用，采用时间并行性及空间并行性。
例如奔腾CPU采用了超标量流水技术，在一个机器周期中同时执行两条指令，因而既具有时间并行性，又具有空间并行性

#### 流水线原理
从本质上讲，`流水线技术是一种时间并行技术。  ` 
在流水线中，`原则上要求各个阶段的处理时间都相同`

### 流水CPU的结构
#### 流水计算机的系统组成
CPU按流水线方式组织，通常由三大部分组成：指令部件、指令队列、执行部件。这三个功能部件可以组成一个3级流水线。

程序和数据存储在主存中，主存采用多体交叉存储器，以提高速度。Cache弥补主存和CPU速度上的差异
{% asset_img 流水计算机的系统组成.png%}
指令部件本身构成一个流水线，即指令流水线，由取指令、指令译码、计算操作数地址、取操作数等几个过程段组成。

指令队列是一个先进先出（FIFO）的寄存器栈，用于存放经过译码的指令和取来的操作数，也是由若干个过程组成的流水线。

执行部件可以具有多个算术逻辑运算部件，部件本身用流水线方式构成。

当执行部件正在执行第I条指令时，指令队列中存放着I+1，I+2，…，I+k条指令，与此同时，指令部件正在取第I+k+1条指令

执行段的速度匹配问题，通常采用并行的运算部件以及部件流水线的工作方式来解决：
1. 将执行部件分为定点执行部件和浮点执行部件两个可并行执行的部分，分别处理定点运算指令和浮点运算指令；
2. 在浮点执行部件中，又有浮点加法部件和浮点乘除部件，可以同时执行不同的指令；
3. 浮点运行部件都以流水线方式工作。


#### 流水CPU的时空图
假设一个指令周期包含四个子过程：取指令IF、指令译码ID、执行运算EX、结果写回WB，各个过程段之间设有高速缓冲寄存器，以暂时保存上一过程段子任务处理的结果。
{% asset_img 流水CPU的时空图.png%}

如果流水计算机具有两条以上的指令流水线，称为`超标量流水计算机`

#### 流水线分类
一个计算机系统可以在不同的`并行等级`上采用流水线技术，常用的流水线形式有：
1. `指令流水线`：指令步骤的并行。
2. `算术流水线`：运算操作步骤的并行，如流水加法器、流水乘法器等。
3. `处理机流水线`：也称为`宏流水线`，是程序步骤的并行。由一串级联的处理机构成流水线的各个过程段，每台处理机负责某一特定任务。

### 流水线中的主要问题
1. 资源相关
指多条指令进入流水线后在同一机器时钟周期内争用同一个功能部件所发生的冲突
2. 数据相关
在一个程序中，如果必须等前一条指令执行完毕后，才能执行后一条指令，那么这两条指令就是数据相关的
3. 控制相关
控制相关冲突是由转移指令引起的。
当执行转移指令时，依据转移条件的产生结果，可能为顺序取下条指令；也可能转移到新的目标地址取指令，从而使流水线发生断流。

为了减小转移指令对流水线性能的影响，常用以下两种转移处理技术：
`延迟转移法`
由编译程序重排指令序列来实现。
基本思想是“先执行后转移”，即发生转移取指时并不排空指令流水线，而是让紧跟在转移指令Ib之后已进入流水线的少数几条指令继续完成。
如果这些指令是与Ib结果无关的有用指令，那么延迟损失时间片正好得到了有效的利用。

`转移预测法`
硬件方法实现，依据指令过去的行为来预测将来的行为。
通过使用转移取指和顺序取指两路指令预取队列器以及指令cache，可将转移预测提前到取指阶段进行，以获得良好的效果。
